\chapter{Marco Teórico}

En este capítulo se examinará de forma más profunda las dos áreas de inspiración para la presente tesis: la {\bf computación cuántica} y la {\bf computación evolutiva}.

\section{Computación Cuántica}

La computación cuántica es un paradigma de computación que surge en contraposición a la computación clásica, la cual basa su existencia en transistores. En la computación cuántica, se aplican a la computación los principios presentes en la física cuántica, tales como la superposición de estados, entrelazamiento, entre otras \cite{hey1999quantum}. 

La potencia disponible en la computación clásica está ligada directamente al tamaño de los transistores que componen sus chips. Actualmente, el tamaño de dichos transistores ya está aproximándose a la escala de nanómetros, lo cual limita el aumento de ciclos por reloj para los procesadores, motivo por el cual el foco en la computación clásica ha cambiado para concentrarse en campos como la paralelización \cite{censor1997parallel}.

Es aquí donde la computación cuántica muestra sus posibilidades. A diferencia del paradigma tradicional donde la unidad básica es el bit, en la computación cuántica la unidad básica es el \textit{qubit}. La diferencia entre el bit tradicional y el qubit es que mientras el primero sólo puede almacenar un único valor (ya sea este 0 o 1), el segundo puede contener 0, 1 o una superposición de ambos valores, fenómeno al que se llama \textit{superposición de estados}. Es esta superposición de estados la que permite asumir una cantidad simultánea de valores a la vez, y por lo tanto desarrollar una cantidad fantástica de operaciones simultáneas en vez de la única simultánea que permite la computación clásica \cite{nielsen2010quantum}.

Esta diferencia (que se evidencia en la representación de un algoritmo cuántico mediante máquinas de Turing cuánticas en vez de las tradicionales) presenta posibilidades poco imaginables hasta hace poco. Si se lograra construir un computador cuántico y ejecutar en él algoritmos que aprovechen su poder, se podría llegar al extremo de ejecutar tareas de complejidad no-polinomial para un ordenador tradicional (problemas NP-completos). Sin embargo, los avances científicos en el campo todavía no han llegado al punto de poder generar un prototipo práctico de computador cuántico, por lo que sus propiedades continúan siendo más una posibilidad que un hecho \cite{han2001analysis}.

Además de ello, cabe resaltar que para aprovechar toda la potencia de procesamiento que un ordenador cuántico podría ofrecer, se deberá disponer de algoritmos cuánticos que empleen los conceptos relacionados a la computación cuántica. Por ahora se tienen algunos ejemplos como el algoritmo de Shor (para descomponer un número en factores polinomiales) \cite{shor1994algorithms} o el de Grover (para buscar una secuencia no ordenada de datos con N componentes) \cite{grover1996fast}, entre otros. Basta ver, por ejemplo, el algoritmo de Shor, que demuestra que el poder de la computación cuántica es tal que podría acabar con el campo de la criptografía tradicional al ser capaz de romper algoritmos de encriptación como RSA.

Dado que los algoritmos cuánticos ``auténticos'' son por ahora inaplicables en la vida real, se ha buscado adaptar distintos conceptos de la computación cuántica a otras áreas para poder aprovechar algunas de sus ventajas en la computación tradicional. De esos intentos surge la computación evolutiva de inspiración cuántica, la cual se explica posteriormente en este capítulo.

La unidad básica de un computador cuántico de dos estados es llamado bit cuántico o \textit{qubit}, el cual puede encontrarse en el estado '0', en el estado '1' o en una superposición de ambos. Se puede representar su estado como:

\begin{equation}
 \arrowvert\Psi\rangle = \alpha\textbar0\rangle + \beta\arrowvert1\rangle 
\end{equation}

donde $\alpha$ y $\beta$ son valores complejos que representan las amplitudes de probabilidad de ambos estados. Por lo tanto, $\arrowvert\alpha\arrowvert^2$ es la probabilidad que el valor del qubit sea de '0' al observarlo, y $\arrowvert\beta\arrowvert^2$ la probabilidad correspondiente para el valor '1'. La normalización del estado garantiza que se cumpla:

\begin{equation}
 \arrowvert\alpha\arrowvert^2 + \arrowvert\beta\arrowvert^2 = 1 
\end{equation}

De existir un sistema de $m$-qubits, éste puede representar tanta información como $2^m$ estados a la vez. Sin embargo, al observar el qubit, este colapsa y asume un estado único.

\section{Computación Evolutiva}

La computación evolutiva es una rama dependiente de la inteligencia artificial, y a su vez, una metodología de optimización inspirada en la evolución biológica y el comportamiento de organismos vivientes \cite{zhang2011evolutionary}, y comprende en sí a los algoritmos evolutivos. La computación evolutiva incluye metodologías y variantes tales como: algoritmos genéticos, estrategias evolutivas, programación genética, sistemas de clasificación mediante aprendizaje, evolución diferencial, algoritmo para la estimación de la distribución, inteligencia de enjambre, optimización por colonia de hormigas, entre otros. 

Un algoritmo evolutivo es una abstracción de procesos y principios establecidos por el Darwinismo y el Neo-Darwinismo. Por lo general comprenden las siguientes ideas: dada una población de individuos, distintas circunstancias en el ambiente ejercen presión sobre los mismos provocando el fenómeno conocido como selección natural (supervivencia del más apto), causando un incremento en las aptitudes de dichos individuos. Estas circunstancias ambientales son las encargadas de realizar la medición de la aptitud de los individuos.

Dada una función que mide esta calidad y la cual se busca maximizar, se genera aleatoriamente un conjunto de individuos candidatos (que podrían ser elementos en el dominio de la función) a los cuales se les aplica la función ya mencionada para medir y comparar la aptitud de cada individuo por separado. Basándonos en esta medición de aptitud, algunos de los individuos candidatos son escogidos para propiciar la siguiente generación mediante la recombinación y/o mutación. La recombinación es un operador que se aplica a dos o más candidatos-progenitor seleccionados y que permite intermezclar características de ambos produciendo como resultado a un individuo-hijo. La mutación, por otro lado, es la aplicación de un cambio puntual sobre un candidato resultando en uno distinto. Esta generación de nuevos individuos candidatos compite en aptitud -y en algunos casos, edad- con los individuos de la generación anterior por un lugar en la siguiente. Este proceso continua iterando hasta que se evalúa a algún individuo de calidad lo suficientemente alta (hallazgo de una solución) o que se llegue a un límite en el tiempo de computación \cite{eiben2003introduction}. 

Vale la pena indicar también que muchos componentes de los algoritmos evolutivos son estocásticos debido a que, a pesar de las mayores posibilidades de superviviencia o reproducción que poseen los mejores individuos, los más débiles mantienen incluso alguna chance de hacerlo también.

\begin{algorithmic}
\begin{algorithm}[ht]
\caption{Pseudocódigo para un algoritmo evolutivo estándar}
INITIALIZE \textit{population} with random candidate solutions;
\State EVALUATE each candidate;
\While {NOT termination-condition}
    \State SELECT parents;
    \State RECOMBINE pairs of parents;
    \State MUTATE the resulting offspring;
    \State EVALUATE new candidates;
    \State SELECT individuals for next generation;
\EndWhile
\end{algorithm}
\end{algorithmic}

\begin{figure}
 \centering
 \includegraphics[scale=0.8,keepaspectratio=true]{./Figure1.png}
 \caption{Proceso de un algoritmo evolutivo. \cite{eiben2003introduction}} 
\end{figure}

Debido a que todas las variedades de algoritmos evolutivos siguen los lineamientos formulados tanto en el algoritmo estándar como en la Figura 3.1, las diferencias entre ellas se reducen a detalles técnicos, como la forma de representar las soluciones. Lo ideal es utilizar la representación de datos más adecuada según la naturaleza del problema a resolver. Si bien son varios los paradigmas desarrollados a partir de la computación evolutiva, son tres los más importantes: Estrategias de Evolución, Programación Evolutiva y Algoritmos Genéticos, las cuales evolucionan soluciones para problemas parametrizados. A ellas se les sumaría un cuarto paradigma: Programación Genética, el cual evoluciona los programas computacionales en sí con el fin de solucionar problemas computacionales \cite{kicinger2005evolutionary}.

Es necesario mencionar algunos conceptos propios de los algoritmos evolutivos, entre los cuales se encuentra al {\bf individuo} que es una solución propuesta al problema; la {\bf población} que es el conjunto de individuos a evaluar y evolucionar; la {\bf generación} que es una iteración del algoritmo en el que se evalúa la aptitud de los individuos de la población para posteriormente obtener una población nueva tras realizar cambios aplicando operadores tales como \textit{mutación} o \textit{recombinación}; el {\bf fenotipo} que son los rasgos observables de cada individuo; y el {\bf genotipo} que es la codificación genética factible de convertirse en un individuo.

Los algoritmos evolutivos emplean determinadas herramientas comunes en sus distintas variables:
\begin{itemize}
 \item Una forma de codificar las soluciones. Esta forma varía de tal forma que podemos encontrar el uso de cadenas de alfabetos finitos como en los algoritmos genéticos, el de árboles en la programación evolutiva, o de vectores con valores reales en las estrategias evolutivas,entre otros \cite{kicinger2005evolutionary}
 \item Una función de aptitud que depende tanto de los individuos como de la forma de evaluarlos. 
 \item Un mecanismo de selección, el cual se basa en la aptitud.
 \item Un conjunto de operadores para reproducir y alterar a los individuos codificados.
\end{itemize}

Los algoritmos evolutivos poseen gran cantidad de aplicaciones, entre las que podemos contar problemas de optimización \cite{coello1999comprehensive} \cite{zhou2011multiobjective}, exploración (arte evolutivo) \cite{romero2008art}, optimización de procesos químicos \cite{singulani2008computational}, entre muchos otros. Presentan gran cantidad de ventajas, entre las cuales podemos mencionar:
\begin{itemize}
 \item Aplicabilidad en problemas donde no hay otros métodos disponibles, ya sea por presencia de restricciones no lineales, discontinuidad, multi-modalidad, problemas de ruido, etc.
 \item Adecuados para problemas que requieren múltiples soluciones, debido a la existencia de una población de las mismas.
 \item Altamente paralelizables.
\end{itemize}

Por supuesto, los algoritmos evolutivos también presentan algunos inconvenientes, tales como: 
\begin{itemize}
 \item Los efectos que los errores del usuario pueden producir al momento de ajustar parámetros, los cuales pueden resultar en errores o en un desempeño menor que óptimo \cite{hinterding1997adaptation}.
 \item El ajuste de los parámetros puede tomar tiempo.
 \item El valor óptimo de los parámetros pueden variar durante la evolución.
 \item No existe una garantía para hallar soluciones óptimas en un periodo de tiempo determinado, aunque para evitar ello se pueden aplicar pruebas de convergencia asimptótica.
\end{itemize}


\section{Algoritmo Evolutivo de Inspiración Cuántica}

El algoritmo evolutivo de inspiración cuántica original fue descrito originalmente en \cite{han2000genetic} y posteriormente analizado \cite{han2001analysis}. Como se puede ver en el capítulo anterior, han surgido buen número de variaciones y aplicaciones, todos basados en el original que se describe a continuación:

\ac{QIEA} emplea una representación denominada Q-bit, el cual está definida por un par de número $[\alpha,\beta]$ tal que:

\[
  \begin{bmatrix}
    \alpha \\        
    \beta \\      
  \end{bmatrix}
\]

donde $\arrowvert\alpha\arrowvert^2 + \arrowvert\beta\arrowvert^2 = 1 $. De la misma forma se puede definir un vector de $m$ Q-bits de esta forma:

\[
  \begin{bmatrix}
    \alpha_1 & \alpha_2 & ... & \alpha_m \\        
    \beta_1 & \beta_2 & ... &  \beta_m \\      
    \beta_1 & \beta_2 & ... &  \beta_m \\      
  \end{bmatrix}
\]

donde $\arrowvert\alpha_i\arrowvert^2 + \arrowvert\beta_i\arrowvert^2 = 1 $ para cada $i = 0, 1, ..., m$.

% AGREGAR DETALLE SOBRE COMO UN INDIVIDUO Q-BIT CON TRES PARES DE AMPLITUDES PUEDE ALMANCENAR TANTA INFORMACIÓN COMO 8 INDIVIDUOS NORMALES

Para modificar los Q-bits se emplea un operador denominado Q-gate, el cual se encarga de rotar el ángulo y hacerlo inclinarse hacia un valor ('0' o '1'), de tal manera que asegure el cumplimiento de la ecuación 3.2:

\[
U(\Delta\theta_i)=
  \begin{bmatrix}
    \cos(\Delta\theta_i) & -\sin(\Delta\theta_i) \\        
    \sin(\Delta\theta_i) & \cos(\Delta\theta_i) \\      
  \end{bmatrix}
\]

donde $\Delta\theta_i, i=0,1,...,m$ es el ángulo de rotación de cada Q-bit. La magnitud de este valor tiene efecto en la convergencia, pero de ser muy alto se corre el riesgo de diverger o de converger prematuramente hacia un óptimo local.

La estructura del algoritmo \ac{QIEA} es la siguiente:

\begin{algorithmic}
\begin{algorithm}[ht]
\caption{Pseudocódigo para el algoritmo evolutivo de inspiración cuántica}
INITIALIZE $t \leftarrow 0$;
\State INITIALIZE $Q(t)$;
\State MAKE $P(t)$ by observing the states of $Q(t)$;
\State EVALUATE $P(t)$;
\State STORE best solutions among $P(t)$ into {\bf b};
\While {NOT termination-condition}
    \State $t \leftarrow t+1$;
    \State MAKE $P(t)$ by observing states of $Q(t-1)$;
    \State EVALUATE $P(t)$ ;
    \State UPDATE $Q(t)$ using Q-gates;
    \State STORE best solutions among $P(t)$ into {\bf b};
\EndWhile
\end{algorithm}
\end{algorithmic}

\section{Consideraciones Finales}

Según se ha visto, el algoritmo evolutivo de inspiración cuántica original es sencillo y de implementación relativamente rápida. Se tomará este algoritmo como punto de partida para la propuesta que se desarrolla en el siguiente capítulo, el cual agrega conceptos de física cuántica para la introducción de un mecanismo de recombinación (\textit{fitness}).


