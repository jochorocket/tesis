\chapter{Marco Teórico}

En este capítulo se examinará de forma más profunda las dos áreas de inspiración para la presente tesis: la {\bf computación cuántica} y la {\bf computación evolutiva}.

\section{Computación Cuántica}

La computación cuántica es un paradigma de computación que surge en contraposición a la computación clásica, la cual basa su existencia en transistores. En la computación cuántica, se aplican a la computación los principios presentes en la física cuántica, tales como la superposición de estados, entrelazamiento, entre otras \cite{hey1999quantum}. 

La potencia disponible en la computación clásica está ligada directamente al tamaño de los transistores que componen sus chips. Actualmente, el tamaño de dichos transistores ya está aproximándose a la escala de nanómetros, lo cual limita el aumento de ciclos por reloj para los procesadores, motivo por el cual el foco en la computación clásica ha cambiado para concentrarse en campos como la paralelización \cite{censor1997parallel}.

Es aquí donde la computación cuántica muestra sus posibilidades. A diferencia del paradigma tradicional donde la unidad básica es el bit, en la computación cuántica la unidad básica es el \textit{qubit}. La diferencia entre el bit tradicional y el qubit es que mientras el primero sólo puede almacenar un único valor (ya sea este 0 o 1), el segundo puede contener 0, 1 o una superposición de ambos valores, fenómeno al que se llama \textit{superposición de estados}. Es esta superposición de estados la que permite asumir una cantidad simultánea de valores a la vez, y por lo tanto desarrollar una cantidad fantástica de operaciones simultáneas en vez de la única que permite la computación clásica \cite{nielsen2010quantum}.

Esta diferencia (que se evidencia en la representación de algoritmos cuánticos mediante máquinas de Turing cuánticas en vez de las tradicionales) presenta posibilidades poco imaginables hasta hace poco. Si se lograra construir un computador cuántico y ejecutar en él algoritmos que aprovechen su poder, se podría llegar al extremo de ejecutar tareas de complejidad no-polinomial para un ordenador tradicional (problemas NP-completos). Sin embargo, los avances científicos en el campo todavía no han llegado al punto de poder generar un prototipo práctico de computador cuántico, por lo que sus propiedades continúan siendo más una posibilidad que un hecho \cite{han2001analysis}.

Además de ello, cabe resaltar que para aprovechar toda la potencia de procesamiento que un ordenador cuántico podría ofrecer, se deberá desarrollar algoritmos cuánticos que empleen los conceptos relacionados a la computación cuántica. Por ahora, se tienen algunos ejemplos como el algoritmo de Shor (para descomponer un número en factores polinomiales) \cite{shor1994algorithms} o el de Grover (para buscar una secuencia no ordenada de datos con N componentes) \cite{grover1996fast}, entre otros. Basta ver, por ejemplo, el algoritmo de Shor, que demuestra que el poder de la computación cuántica es tal que podría acabar con el campo de la criptografía tradicional al ser capaz de romper algoritmos de encriptación como tales como RSA.

Dado que los algoritmos cuánticos ``auténticos'' son por ahora inaplicables en la vida real, se ha buscado adaptar distintos conceptos de la computación cuántica a otras áreas para poder aprovechar algunas de sus ventajas en la computación tradicional. De esos intentos surge la computación evolutiva de inspiración cuántica, la cual se explica posteriormente en este capítulo.

La unidad básica de un computador cuántico de dos estados es el llamado bit cuántico o \textit{qubit}, el cual puede encontrarse en un estado `0', un estado `1' o en una superposición de ambos. Se puede representar este estado como:

\begin{equation}
 \arrowvert\Psi\rangle = \alpha\textbar0\rangle + \beta\arrowvert1\rangle 
\end{equation}

donde $\alpha$ y $\beta$ son valores complejos que representan las amplitudes de probabilidad de ambos estados. Por lo tanto, $\arrowvert\alpha\arrowvert^2$ es la probabilidad que el valor del qubit sea de `0' al observarlo, y $\arrowvert\beta\arrowvert^2$ la probabilidad correspondiente para el valor `1'. La normalización del estado garantiza que se cumpla:

\begin{equation}
 \arrowvert\alpha\arrowvert^2 + \arrowvert\beta\arrowvert^2 = 1 
\end{equation}

De existir un sistema de $m$-qubits, éste puede representar tanta información como $2^m$ estados a la vez. Sin embargo, al observar el qubit, la superposición del mismo colapsa, asumiendo así un estado único.

\section{Computación Evolutiva}

La computación evolutiva es una rama dependiente de la inteligencia artificial, y a su vez, una metodología de optimización inspirada en la evolución biológica y el comportamiento de organismos vivientes \cite{zhang2011evolutionary}, y comprende en sí a los algoritmos evolutivos. La computación evolutiva incluye metodologías y variantes tales como: algoritmos genéticos, estrategias evolutivas, programación genética, sistemas de clasificación mediante aprendizaje, evolución diferencial, algoritmo para la estimación de la distribución, inteligencia de enjambre, optimización por colonia de hormigas, entre otros. 

Un algoritmo evolutivo es una abstracción de procesos y principios establecidos por el Darwinismo y el Neo-Darwinismo. Por lo general comprenden las siguientes ideas: dada una población de individuos, distintas circunstancias en el ambiente ejercen presión sobre los mismos provocando el fenómeno conocido como selección natural (supervivencia del más apto), causando un incremento en las aptitudes de dichos individuos. Estas circunstancias ambientales son las encargadas de realizar la medición de la aptitud de los individuos.

Dada una función que mide esta calidad y la cual se busca maximizar, se genera aleatoriamente un conjunto de individuos candidatos (que podrían ser elementos en el dominio de la función) a los cuales se les aplica la función ya mencionada para medir y comparar la aptitud de cada individuo por separado. Basándonos en esta medición de aptitud, algunos de los individuos candidatos son escogidos para propiciar la siguiente generación mediante la recombinación y/o mutación. La recombinación es un operador que se aplica a dos o más candidatos-progenitor seleccionados y que permite intermezclar características de ambos produciendo como resultado a un individuo-hijo. La mutación, por otro lado, es la aplicación de un cambio puntual sobre un candidato resultando en uno distinto. Esta generación de nuevos individuos candidatos compite en aptitud -y en algunos casos, edad- con los individuos de la generación anterior por un lugar en la siguiente. Este proceso continua iterando hasta que se evalúa a algún individuo de calidad lo suficientemente alta (hallazgo de una solución) o que se llegue a un límite en el tiempo de computación \cite{eiben2003introduction}. 

Vale la pena indicar también que muchos componentes de los algoritmos evolutivos son estocásticos debido a que, a pesar de las mayores posibilidades de superviviencia o reproducción que poseen los mejores individuos, los más débiles mantienen incluso alguna chance de hacerlo también.

\begin{algorithmic}
\begin{algorithm}[ht]
\caption{Pseudocódigo para un algoritmo evolutivo estándar}
INITIALIZE \textit{population} with random candidate solutions;
\State EVALUATE each candidate;
\While {NOT termination-condition}
    \State SELECT parents;
    \State RECOMBINE pairs of parents;
    \State MUTATE the resulting offspring;
    \State EVALUATE new candidates;
    \State SELECT individuals for next generation;
\EndWhile
\end{algorithm}
\end{algorithmic}

\begin{figure}
 \centering
 \includegraphics[scale=0.8,keepaspectratio=true]{./Figure1.png}
 \caption{Proceso de un algoritmo evolutivo. \cite{eiben2003introduction}} 
\end{figure}

Debido a que todas las variedades de algoritmos evolutivos siguen los lineamientos formulados tanto en el algoritmo estándar como en la Figura 3.1, las diferencias entre ellas se reducen a detalles técnicos, como la forma de representar las soluciones. Lo ideal es utilizar la representación de datos más adecuada según la naturaleza del problema a resolver. Si bien son varios los paradigmas desarrollados a partir de la computación evolutiva, son tres los más importantes: Estrategias de Evolución, Programación Evolutiva y Algoritmos Genéticos, las cuales evolucionan soluciones para problemas parametrizados. A ellas se les sumaría un cuarto paradigma: Programación Genética, el cual evoluciona los programas computacionales en sí con el fin de solucionar problemas computacionales \cite{kicinger2005evolutionary}.

Es necesario mencionar algunos conceptos propios de los algoritmos evolutivos, entre los cuales se encuentra al {\bf individuo} que es una solución propuesta al problema; la {\bf población} que es el conjunto de individuos a evaluar y evolucionar; la {\bf generación} que es una iteración del algoritmo en el que se evalúa la aptitud de los individuos de la población para posteriormente obtener una población nueva tras realizar cambios aplicando operadores tales como \textit{mutación} o \textit{recombinación}; el {\bf fenotipo} que son los rasgos observables de cada individuo; y el {\bf genotipo} que es la codificación genética factible de convertirse en un individuo.

Los algoritmos evolutivos emplean determinadas herramientas comunes en sus distintas variables:
\begin{itemize}
 \item Una forma de codificar las soluciones. Esta forma varía de tal forma que podemos encontrar el uso de cadenas de alfabetos finitos como en los algoritmos genéticos, el de árboles en la programación evolutiva, o de vectores con valores reales en las estrategias evolutivas,entre otros \cite{kicinger2005evolutionary}
 \item Una función de aptitud que depende tanto de los individuos como de la forma de evaluarlos. 
 \item Un mecanismo de selección, el cual se basa en la aptitud.
 \item Un conjunto de operadores para reproducir y alterar a los individuos codificados.
\end{itemize}

Los algoritmos evolutivos poseen gran cantidad de aplicaciones, entre las que podemos contar problemas de optimización \cite{coello1999comprehensive} \cite{zhou2011multiobjective}, exploración (arte evolutivo) \cite{romero2008art}, optimización de procesos químicos \cite{singulani2008computational}, entre muchos otros. Presentan gran cantidad de ventajas, entre las cuales podemos mencionar:
\begin{itemize}
 \item Aplicabilidad en problemas donde no hay otros métodos disponibles, ya sea por presencia de restricciones no lineales, discontinuidad, multi-modalidad, problemas de ruido, etc.
 \item Adecuados para problemas que requieren múltiples soluciones, debido a la existencia de una población de las mismas.
 \item Altamente paralelizables.
\end{itemize}

Por supuesto, los algoritmos evolutivos también presentan algunos inconvenientes, tales como: 
\begin{itemize}
 \item Los efectos que los errores del usuario pueden producir al momento de ajustar parámetros, los cuales pueden resultar en errores o en un desempeño menor que óptimo \cite{hinterding1997adaptation}.
 \item El ajuste de los parámetros puede tomar tiempo.
 \item El valor óptimo de los parámetros pueden variar durante la evolución.
 \item No existe una garantía para hallar soluciones óptimas en un periodo de tiempo determinado, aunque para evitar ello se pueden aplicar pruebas de convergencia asimptótica.
\end{itemize}


\section{Algoritmo Evolutivo de Inspiración Cuántica}

Los algoritmos evolutivos de inspiración cuántica buscan aprovechar los paradigmas de la física cuántica para mejorar su rendimiento al resolver problemas. Para la formulación de un algoritmo de inspiración cuántica se debe cumplir con los siguientes requerimientos:

\begin{itemize}
 \item Tener una representación numérica o un método para convertir en representación numérica.
 \item Determinar una configuración inicial.
 \item Definir una condición de finalización.
 \item Dividir el problema en sub-problemas más simples.
 \item Identificar el número de universos (estados de superposición).
 \item Cada sub-problema debe asociarse a un universo.
 \item Los cálculos deben ser independientes en cada universo.
 \item Debe haber alguna interacción entre universos, y ésta debe, al menos permitir hallar la solución, o ayudar a que cada sub-problema en cada universo sea capaz de encontrarla. 
\end{itemize}


El algoritmo evolutivo de inspiración cuántica original fue descrito originalmente en \cite{han2000genetic} y posteriormente analizado \cite{han2001analysis}. Como se puede ver en el capítulo anterior, han surgido buen número de variaciones y aplicaciones, todos basados en el original descrito a continuación.

\ac{QIEA} emplea una representación denominada Q-bit -la cual equivale al qubit que puede representar ya sea a uno de los valores $\{0,1\}$ o a la superposición de ambos-, el cual está definida por dos valores $[\alpha,\beta]$

\begin{equation}
  \begin{bmatrix}
    \alpha \\        
    \beta \\      
  \end{bmatrix}
\end{equation}

donde $\arrowvert\alpha\arrowvert^2 + \arrowvert\beta\arrowvert^2 = 1 $, y que hacen referencia a la probabilidad que el Q-bit colapse -ya sea a uno o a otro- de los dos estados posibles al momento de ser observado. De la misma forma se puede definir un vector de $n$ Q-bits de esta forma:

\begin{equation}
  \begin{bmatrix}
    \alpha_1 & \alpha_2 & ... & \alpha_n \\        
    \beta_1 & \beta_2 & ... &  \beta_n \\      
  \end{bmatrix}
\end{equation}

donde también se cumple $\arrowvert\alpha_j\arrowvert^2 + \arrowvert\beta_j\arrowvert^2 = 1  \forall  j = 0, 1, ..., n$.

% AGREGAR DETALLE SOBRE COMO UN INDIVIDUO Q-BIT CON TRES PARES DE AMPLITUDES PUEDE ALMANCENAR TANTA INFORMACIÓN COMO 8 INDIVIDUOS NORMALES

Para modificar los Q-bits se emplea un operador denominado Q-gate, el cual se encarga de rotar el ángulo y hacerlo inclinarse hacia un valor $\{0,1\}$, de tal manera que asegure el cumplimiento de la ecuación 3.2:

\begin{equation}
 U(\Delta\theta_i)=
  \begin{bmatrix}
    \cos(\Delta\theta_i) & -\sin(\Delta\theta_i) \\        
    \sin(\Delta\theta_i) & \cos(\Delta\theta_i) \\      
  \end{bmatrix}
\end{equation}

donde $\Delta\theta_i, i=0,1,...,m$ es el ángulo de rotación de cada Q-bit. La magnitud de este valor tiene efecto en la convergencia, pero de ser muy alto se corre el riesgo de diverger o de converger prematuramente hacia un óptimo local.

\begin{equation}
   \begin{bmatrix}
    \alpha'_i \\        
    \beta'_i \\      
  \end{bmatrix}=
U(\Delta\theta_i)
   \begin{bmatrix}
    \alpha_i \\        
    \beta_i \\      
  \end{bmatrix} 
\end{equation}

\begin{figure}
 \centering
 \includegraphics[scale=0.7,keepaspectratio=true]{./Figure2.png}
 % Figure2.png: 446x471 pixel, 96dpi, 11.80x12.46 cm, bb=0 0 334 353
 \caption{Rotación del ángulo al momento de la aplicación del operador Q-gate}
\end{figure}


La estructura del algoritmo \ac{QIEA} es la siguiente:

\begin{algorithmic}
\begin{algorithm}[ht]
\caption{Pseudocódigo para el algoritmo evolutivo de inspiración cuántica}
INITIALIZE $t \leftarrow 0$;
\State INITIALIZE $Q(t)$;
\State MAKE $P(t)$ by observing the states of $Q(t)$;
\State EVALUATE $P(t)$;
\State STORE best solutions among $P(t)$ into {\bf b};
\While {NOT termination-condition}
    \State $t \leftarrow t+1$;
    \State MAKE $P(t)$ by observing states of $Q(t-1)$;
    \State EVALUATE $P(t)$ ;
    \State UPDATE $Q(t)$ using Q-gates;
    \State STORE best solutions among $P(t)$ into {\bf b};
\EndWhile
\end{algorithm}
\end{algorithmic}


\section{Algoritmo Evolutivo de Inspiración Cuántica - $\mathbb{R}$}

La propuesta original de un algoritmo evolutivo de inspiración cuántica para $\mathbb{R}$ busca generar un conjunto de estados observables contínuos y no discretos como el algoritmo base \cite{da2007algoritmos}. La inspiración de este modelo está en el uso de funciones de onda.

Se calcula el momento de un fotón a partir de su masa al moverse a la velocidad de la luz $m=hv/c^2$ derivada de la ecuación fundamental de Einstein $E=mc^2$.

\begin{equation}
 p = mc = hv/c = h/\lambda
\end{equation}

donde $\lambda$ es la longitud de onda de la luz.

Al reemplazar $\lambda = h/p$ en la ecuación utilizada en electromagnetismo donde una onda estacionaria con longitud de onda $\lambda$ se propaga hacia el lado positivo del eje $x$ definida como $\psi(x) = e^{}i2\pi x/\lambda$ donde $i = \sqrt{-1}$ se obtiene:

\begin{equation}
 \psi(x) = e^{ipx2\pi/h}
\end{equation}

Según \cite{gillespie1974}, la \ac{PDD} para la ubicación de una partícula con función de onda $\psi$ está definida por $\arrowvert\psi\arrowvert^2$, por lo que al integrar todo el espacio en el que la partícula podría ser encontrada, se obtiene la posibilidad de encontrarla en cualquier lugar del espacio:

\begin{equation}
 \int^\infty_{-\infty}{\arrowvert\psi\arrowvert^2d\tau}=1
\end{equation}

Debido a que a cada observación de una partícula, ésta asumirá diferentes valores de posición según la probabilidad de estar localizada en determinada región del espacio, se usa este concepto en el modelo AEIQ-$\mathbb{R}$ para representar los valores de los individuos cuánticos.

De tal forma, se obtiene una población de individuos cuánticos $Q_t = {q_1 ,... , q_m }$, en la generación $t$, donde cada individuo cuántico $q_i$ está formado por $n$ genes, $q_{ij} = {q_{i1},...,q{in} }$, donde a su vez cada gen $q_{ij}$ está formado por funciones densidades de probabilidad (en vez de variables como en el algoritmo original).





\section{Consideraciones Finales}

Según se ha visto, el algoritmo evolutivo de inspiración cuántica original es sencillo y de implementación relativamente rápida, mientras que el algoritmo para $\mathbb{R}$ sube ligeramente el listón en términos de inspiración pero añadiendo nuevas capacidades a las posibilidades de la inspiración cuántica. Se tomará este algoritmo como punto de partida para la propuesta que se desarrolla en el siguiente capítulo, el cual busca introducir un nuevo mecanismo de recombinación (\textit{crossover}) en un entorno concurrente de ejecución con más de una población cuántica generadora.
Según se ha visto, el algoritmo evolutivo de inspiración cuántica original es sencillo y de implementación relativamente rápida, mientras que el algoritmo para $\mathbb{R}$ sube ligeramente el listón en términos de inspiración pero añadiendo nuevas capacidades a las posibilidades de la inspiración cuántica. Se tomará este algoritmo como punto de partida para la propuesta que se desarrolla en el siguiente capítulo, el cual busca introducir un nuevo mecanismo de recombinación (\textit{crossover}) en un entorno concurrente de ejecución con más de una población cuántica generadora.


