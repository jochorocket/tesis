\chapter{Marco Teórico}

En este capítulo se examinará de forma más profunda las dos áreas de inspiración para la presente tesis: la {\bf computación cuántica} y la {\bf computación evolutiva}.

\section{Computación Cuántica}

La computación cuántica es un paradigma de computación que surge en contraposición a la computación clásica, con un funcionamiento basado en transistores. En la computación cuántica, se aplican a la computación los principios presentes en la física cuántica, tales como la superposición de estados, entrelazamiento, entre otras \cite{hey1999quantum}. 

La potencia disponible en la computación clásica está ligada directamente al tamaño de los transistores que componen sus chips. Actualmente, el tamaño de dichos transistores ya se encuentra próximo a la escala de nanómetros, lo cual limita el aumento de ciclos por reloj para los procesadores, motivo por el cual el foco en la computación clásica ha cambiado para concentrarse en campos como la paralelización \cite{censor1997parallel}.

Es aquí donde la computación cuántica muestra sus posibilidades. A diferencia del paradigma tradicional donde la unidad básica es el bit, en la computación cuántica la unidad básica es el \textit{qubit}. La diferencia entre el bit tradicional y el qubit es que mientras el primero sólo puede almacenar un único valor (ya sea este 0 o 1), el segundo puede contener 0, 1 o una superposición de ambos valores, fenómeno al que se llama \textit{superposición de estados}. Es esta superposición de estados la que permite asumir una cantidad simultánea de valores a la vez, y por lo tanto desarrollar una cantidad fantástica de operaciones simultáneas en vez de la única que permite la computación clásica \cite{nielsen2010quantum}.

Esta diferencia (que se evidencia en la representación de algoritmos cuánticos mediante máquinas de Turing cuánticas en vez de las tradicionales) presenta posibilidades poco imaginables hasta hace poco. Si se lograra construir un computador cuántico y ejecutar en él algoritmos que aprovechen su poder, se podría llegar al extremo de ejecutar tareas de complejidad no-polinomial para un ordenador tradicional (problemas NP-completos). Sin embargo, los avances científicos en el campo todavía no han llegado al punto de poder generar un prototipo práctico de computador cuántico, por lo que sus propiedades continúan siendo más una posibilidad que un hecho \cite{han2001analysis}.

Además de ello, cabe resaltar que para aprovechar toda la potencia de procesamiento que un ordenador cuántico podría ofrecer, se deberá desarrollar algoritmos cuánticos que empleen los conceptos relacionados a la computación cuántica. Por ahora, se tienen algunos ejemplos como el algoritmo de Shor (para descomponer un número en factores polinomiales) \cite{shor1994algorithms} o el de Grover (para buscar una secuencia no ordenada de datos con N componentes) \cite{grover1996fast}, entre otros. Basta ver, por ejemplo, el algoritmo de Shor, que demuestra que el poder de la computación cuántica es tal que podría acabar con el campo de la criptografía tradicional al ser capaz de romper algoritmos de encriptación como tales como RSA.

Dado que los algoritmos cuánticos ``auténticos'' son por ahora inaplicables en la vida real, se ha buscado adaptar distintos conceptos de la computación cuántica a otras áreas para poder aprovechar algunas de sus ventajas en la computación tradicional. De esos intentos surge la computación evolutiva de inspiración cuántica, la cual se explica posteriormente en este capítulo.

La unidad básica de un computador cuántico de dos estados es el llamado bit cuántico o \textit{qubit}, el cual puede encontrarse en un estado `0', un estado `1' o en una superposición de ambos. Se puede representar este estado como:

\begin{equation}
 \arrowvert\Psi\rangle = \alpha\textbar0\rangle + \beta\arrowvert1\rangle 
\end{equation}

donde $\alpha$ y $\beta$ son valores complejos que representan las amplitudes de probabilidad de ambos estados. Por lo tanto, $\arrowvert\alpha\arrowvert^2$ es la probabilidad que el valor del qubit sea de `0' al observarlo, y $\arrowvert\beta\arrowvert^2$ la probabilidad correspondiente para el valor `1'. La normalización del estado garantiza que se cumpla:

\begin{equation}
 \arrowvert\alpha\arrowvert^2 + \arrowvert\beta\arrowvert^2 = 1 
\end{equation}

De existir un sistema de $m$-qubits, éste puede representar tanta información como $2^m$ estados a la vez. Sin embargo, al observar el qubit, la superposición del mismo colapsa, asumiendo así un estado único.

\section{Computación Evolutiva}

La computación evolutiva es una rama dependiente de la inteligencia artificial, y a su vez, una metodología de optimización inspirada en la evolución biológica y el comportamiento de organismos vivientes \cite{zhang2011evolutionary}, y comprende en sí a los algoritmos evolutivos. La computación evolutiva incluye metodologías y variantes tales como: algoritmos genéticos, estrategias evolutivas, programación genética, sistemas de clasificación mediante aprendizaje, evolución diferencial, algoritmo para la estimación de la distribución, inteligencia de enjambre, optimización por colonia de hormigas, entre otros. 

Un algoritmo evolutivo es una abstracción de procesos y principios establecidos por el Darwinismo y el Neo-Darwinismo. Por lo general comprenden las siguientes ideas: dada una población de individuos, distintas circunstancias en el ambiente ejercen presión sobre los mismos provocando el fenómeno conocido como selección natural (supervivencia del más apto), causando un incremento en las aptitudes de dichos individuos. Estas circunstancias ambientales son las encargadas de realizar la medición de la aptitud de los individuos.

Dada una función que mide esta calidad y la cual se busca maximizar, se genera aleatoriamente un conjunto de individuos candidatos (que podrían ser elementos en el dominio de la función) a los cuales se les aplica la función ya mencionada para medir y comparar la aptitud de cada individuo por separado. Basándonos en esta medición de aptitud, algunos de los individuos candidatos son escogidos para propiciar la siguiente generación mediante la recombinación y/o mutación. La recombinación es un operador que se aplica a dos o más candidatos-progenitor seleccionados y que permite intermezclar características de ambos produciendo como resultado a un individuo-hijo. La mutación, por otro lado, es la aplicación de un cambio puntual sobre un candidato resultando en uno distinto. Esta generación de nuevos individuos candidatos compite en aptitud -y en algunos casos, edad- con los individuos de la generación anterior por un lugar en la siguiente. Este proceso continua iterando hasta que se evalúa a algún individuo de calidad lo suficientemente alta (hallazgo de una solución) o que se llegue a un límite en el tiempo de computación \cite{eiben2003introduction}. 

Vale la pena indicar también que muchos componentes de los algoritmos evolutivos son estocásticos debido a que, a pesar de las mayores posibilidades de superviviencia o reproducción que poseen los mejores individuos, los más débiles mantienen incluso alguna chance de hacerlo también.

\begin{algorithmic}
\begin{algorithm}[ht]
\caption{Pseudocódigo para un algoritmo evolutivo estándar}
INITIALIZE \textit{population} with random candidate solutions;
\State EVALUATE each candidate;
\While {NOT termination-condition}
    \State SELECT parents;
    \State RECOMBINE pairs of parents;
    \State MUTATE the resulting offspring;
    \State EVALUATE new candidates;
    \State SELECT individuals for next generation;
\EndWhile
\end{algorithm}
\end{algorithmic}

\begin{figure}
 \centering
 \includegraphics[scale=0.8,keepaspectratio=true]{./Figure1.png}
 \caption{Proceso de un algoritmo evolutivo. \cite{eiben2003introduction}} 
 \label{figure3-1}
\end{figure}

Debido a que todas las variedades de algoritmos evolutivos siguen los lineamientos formulados tanto en el algoritmo estándar como en la Figura 3.1, las diferencias entre ellas se reducen a detalles técnicos, como la forma de representar las soluciones. Lo ideal es utilizar la representación de datos más adecuada según la naturaleza del problema a resolver. Si bien son varios los paradigmas desarrollados a partir de la computación evolutiva, son tres los más importantes: Estrategias de Evolución, Programación Evolutiva y Algoritmos Genéticos, las cuales evolucionan soluciones para problemas parametrizados. A ellas se les sumaría un cuarto paradigma: Programación Genética, el cual evoluciona los programas computacionales en sí con el fin de solucionar problemas computacionales \cite{kicinger2005evolutionary}.adsfasdfads

Es necesario mencionar algunos conceptos propios de los algoritmos evolutivos, entre los cuales se encuentra al {\bf individuo} que es una solución propuesta al problema; la {\bf población} que es el conjunto de individuos a evaluar y evolucionar; la {\bf generación} que es una iteración del algoritmo en el que se evalúa la aptitud de los individuos de la población para posteriormente obtener una población nueva tras realizar cambios aplicando operadores tales como \textit{mutación} o \textit{recombinación}; el {\bf fenotipo} que son los rasgos observables de cada individuo; y el {\bf genotipo} que es la codificación genética factible de convertirse en un individuo.

Los algoritmos evolutivos emplean determinadas herramientas comunes en sus distintas variables:
\begin{itemize}
 \item Una forma de codificar las soluciones. Esta forma varía de tal forma que podemos encontrar el uso de cadenas de alfabetos finitos como en los algoritmos genéticos, el de árboles en la programación evolutiva, o de vectores con valores reales en las estrategias evolutivas,entre otros \cite{kicinger2005evolutionary}
 \item Una función de aptitud que depende tanto de los individuos como de la forma de evaluarlos. 
 \item Un mecanismo de selección, el cual se basa en la aptitud.
 \item Un conjunto de operadores para reproducir y alterar a los individuos codificados.
\end{itemize}

Los algoritmos evolutivos poseen gran cantidad de aplicaciones, entre las que podemos contar problemas de optimización \cite{coello1999comprehensive} \cite{zhou2011multiobjective}, exploración (arte evolutivo) \cite{romero2008art}, optimización de procesos químicos \cite{singulani2008computational}, entre muchos otros. Presentan gran cantidad de ventajas, entre las cuales podemos mencionar:
\begin{itemize}
 \item Aplicabilidad en problemas donde no hay otros métodos disponibles, ya sea por presencia de restricciones no lineales, discontinuidad, multi-modalidad, problemas de ruido, etc.
 \item Adecuados para problemas que requieren múltiples soluciones, debido a la existencia de una población de las mismas.
 \item Altamente paralelizables.
\end{itemize}

Por supuesto, los algoritmos evolutivos también presentan algunos inconvenientes, tales como: 
\begin{itemize}
 \item Los efectos que los errores del usuario pueden producir al momento de ajustar parámetros, los cuales pueden resultar en errores o en un desempeño menor que óptimo \cite{hinterding1997adaptation}.
 \item El ajuste de los parámetros puede tomar tiempo.
 \item El valor óptimo de los parámetros pueden variar durante la evolución.
 \item No existe una garantía para hallar soluciones óptimas en un periodo de tiempo determinado, aunque para evitar ello se pueden aplicar pruebas de convergencia asimptótica.
\end{itemize}


\section{Algoritmos Evolutivos de Inspiración Cuántica}

Los algoritmos evolutivos de inspiración cuántica buscan aprovechar los paradigmas de la física cuántica para mejorar su rendimiento al resolver problemas. El algoritmo \ac{QIEA} original fue descrito originalmente en \cite{han2000genetic} y posteriormente analizado \cite{han2001analysis}. Como se puede ver en el capítulo anterior, han surgido buen número de variaciones y aplicaciones, todos basados en el original descrito a continuación. Para la formulación de un algoritmo de inspiración cuántica se debe cumplir con los siguientes requerimientos:

\begin{itemize}
 \item Tener una representación numérica o un método para convertir en representación numérica.
 \item Determinar una configuración inicial.
 \item Definir una condición de finalización.
 \item Dividir el problema en sub-problemas más simples.
 \item Identificar el número de universos (estados de superposición).
 \item Cada sub-problema debe asociarse a un universo.
 \item Los cálculos deben ser independientes en cada universo.
 \item Debe haber alguna interacción entre universos, y ésta debe, al menos permitir hallar la solución, o ayudar a que cada sub-problema en cada universo sea capaz de encontrarla. 
\end{itemize}

\ac{QIEA} emplea una representación denominada Q-bit -la cual equivale al qubit que puede representar ya sea a uno de los valores $\{0,1\}$ o a la superposición de ambos-, el cual está definida por dos valores $[\alpha,\beta]$

\begin{equation}
  \begin{bmatrix}
    \alpha \\        
    \beta \\      
  \end{bmatrix}
\end{equation}

donde $\arrowvert\alpha\arrowvert^2 + \arrowvert\beta\arrowvert^2 = 1 $, y que hacen referencia a la probabilidad que el Q-bit colapse -ya sea a uno o a otro- de los dos estados posibles al momento de ser observado. De la misma forma se puede definir un vector de $n$ Q-bits de esta forma:

\begin{equation}
  \begin{bmatrix}
    \alpha_1 & \alpha_2 & ... & \alpha_n \\        
    \beta_1 & \beta_2 & ... &  \beta_n \\      
  \end{bmatrix}
\end{equation}

donde también se cumple $\arrowvert\alpha_j\arrowvert^2 + \arrowvert\beta_j\arrowvert^2 = 1  \forall  j = 0, 1, ..., n$.

% AGREGAR DETALLE SOBRE COMO UN INDIVIDUO Q-BIT CON TRES PARES DE AMPLITUDES PUEDE ALMANCENAR TANTA INFORMACIÓN COMO 8 INDIVIDUOS NORMALES

Para modificar los Q-bits se emplea un operador denominado Q-gate, el cual se encarga de rotar el ángulo y hacerlo inclinarse hacia un valor $\{0,1\}$, de tal manera que asegure el cumplimiento de la ecuación 3.2:

\begin{equation}
 \text{U}(\Delta\theta_i)=
  \begin{bmatrix}
    \cos(\Delta\theta_i) & -\sin(\Delta\theta_i) \\        
    \sin(\Delta\theta_i) & \cos(\Delta\theta_i) \\      
  \end{bmatrix}
\end{equation}

donde $\Delta\theta_i, i=0,1,...,m$ es el ángulo de rotación de cada Q-bit. La magnitud de este valor tiene efecto en la convergencia, pero de ser muy alto se corre el riesgo de diverger o de converger prematuramente hacia un óptimo local.

\begin{equation}
   \begin{bmatrix}
    \alpha'_i \\        
    \beta'_i \\      
  \end{bmatrix}=
\text{U}(\Delta\theta_i)
   \begin{bmatrix}
    \alpha_i \\        
    \beta_i \\      
  \end{bmatrix} 
\end{equation}

sin perder la característica $\textbar\alpha'_k\textbar^2 + \textbar\beta'_k\textbar^2 = 1$.

En la figura \ref{figure3-2} se puede apreciar cómo las modificaciones en el operador Q-gate permiten que el las probabilidades $\alpha$ y $\beta$ varíen sin perjudicar la condición elemental expresada en la ecuación 3.2.

\begin{figure}
 \centering
 \includegraphics[scale=0.7,keepaspectratio=true]{./Figure2.png}
 % Figure2.png: 446x471 pixel, 96dpi, 11.80x12.46 cm, bb=0 0 334 353
 \caption{Rotación del ángulo al momento de la aplicación del operador Q-gate}
 \label{figure3-2}
\end{figure}

\begin{algorithmic}
\begin{algorithm}[ht]
\caption{Pseudocódigo para el \ac{QIEA}-$\mathbb{B}$}
 \label{table3-1}
INITIALIZE $t \leftarrow 0$;
\State INITIALIZE ${\bf Q}_t$;
\State MAKE ${\bf P}_t$ by observing the states of ${\bf Q}_t$;
\State STORE best solutions among ${\bf P}_t$ into ${\bf B}_t$;
\While {EndCondition = false}
    \State $t \leftarrow t+1$;
    \State MAKE ${\bf P}_t$ by observing the states of ${\bf Q}_{t-1}$;
    \State EVALUATE ${\bf P}_t$ ;
    \State UPDATE ${\bf Q}_t$ using Q-gates;
    \State STORE best solutions among ${\bf B}_{t-1}$ and ${\bf P}_t$; into ${\bf B}_t$;
    \State STORE best solution ${\bf b} \in {\bf B}_t$;
    \If{Migration Condition}
	\State MIGRATE ${\bf b} \textbar {\bf b}'_j \leftarrow {\bf B}_t$, locally or globally;
    \EndIf
\EndWhile
\end{algorithm}
\end{algorithmic}


\section{Algoritmo Evolutivo de Inspiración Cuántica - $\mathbb{R}$ (\ac{QIEA}-$\mathbb{R}$}

La propuesta original de un \ac{QIEA} para $\mathbb{R}$ busca generar un conjunto de estados observables contínuos y no discretos como el algoritmo base \cite{da2007algoritmos}. La inspiración de este modelo está en el uso de funciones de onda.

Se calcula el momento de un fotón a partir de su masa al moverse a la velocidad de la luz $m=hv/c^2$ derivada de la ecuación de equivalencia entre masa y energía $E=mc^2$.

\begin{equation}
 p = mc = hv/c = h/\lambda
\end{equation}

donde $\lambda$ es la longitud de onda de la luz.

Al reemplazar $\lambda = h/p$ en la ecuación utilizada en electromagnetismo donde una onda estacionaria con longitud de onda $\lambda$ se propaga hacia el lado positivo del eje $x$ definida como $\psi(x) = e^{i2\pi x/\lambda}$ donde $i = \sqrt{-1}$ se obtiene:

\begin{equation}
 \psi(x) = e^{ipx/\hbar}
\end{equation}

donde $\hbar = h/2\pi$.

Según \cite{gillespie1974}, la \ac{PDD} para la ubicación de una partícula con función de onda $\psi$ está definida por $\arrowvert\psi\arrowvert^2$, por lo que al integrar todo el espacio en el que la partícula podría ser encontrada, se obtiene la posibilidad de encontrarla en cualquier lugar del espacio:

\begin{equation}
 \int^\infty_{-\infty}{\arrowvert\psi\arrowvert^2d\tau}=1
\end{equation}

El concepto de función de onda relaciona probabilísticamente una onda con la localización de una partícula. Como en cada observación de una partícula, ésta asumirá diferentes valores de posición según la probabilidad que tiene de estar ubicada en una determinada región del espacio, se usa este concepto en los modelos de algoritmos evolutivos de inspiración cuántica para $\mathbb{R}$ al momento de representar los valores de los individuos cuánticos.

\begin{algorithmic}
\begin{algorithm}[ht]
\caption{Pseudocódigo para \ac{QIEA}-$\mathbb{R}$}
INITIALIZE $t \leftarrow 0$;
\State INITIALIZE ${\bf Q}_t$ with $m$ individuals of $n$ genes;
\While {$t \leq T$}
    \State GENERATE ${\bf E}_t$ by observing individuals ${\bf Q}_t$
    \If{$t=1$}
	\State ${\bf C}_t = {\bf E}_t$ 
    \Else
	\State RECOMBINE $({\bf E}_t,{\bf C}_t) \rightarrow {\bf E}_t$
	\State EVALUATE ${\bf E}_t$
	\State SELECT ${\bf C}_t \leftarrow k$ best individuals from ${\bf E}_t \cup {\bf C}_t$
    \EndIf
    \State UPDATE ${\bf Q}_{t+1}$ with $m$ best individuals from ${\bf C}_t$
    \State $t = t+1$
\EndWhile
\end{algorithm}
\end{algorithmic}

De tal forma, se obtiene una población de individuos cuánticos $Q_t = \{q_1 ,... , q_m\}$, en la generación $t$, donde cada individuo cuántico $q_i$ está formado por $n$ genes, $q_{ij} = \{q_{i1},...,q_{in}\}$, donde a su vez cada gen $q_{ij}$ está formado por funciones densidades de probabilidad (en vez de variables como en el algoritmo original). Es por esto que se puede definir a cada gen cuántico $q_{ij}$ perteneciente a un individuo cuántico como una variable aleatoria con función de densidad probabilística $p_{ij}(x) = \psi*_{ij}(x)\psi(x)$ donde $\psi_{ij}(x)$ es la función de onda asociada a $q_{ij}$ del individuo $q_i$ de la población $Q_t$ y donde $\psi*_{ij}(x)$ es el conjugado completo de la función de onda $\psi_{ij}(x)$, donde la \ac{PDF} debe cumplir la propiedad de normalización $\int^\infty_{-\infty}\psi*_{ij}(x)\psi(x)dx = \int^\infty_{-\infty}p_{ij}(x)dx = 1$. No olvidar también que la \ac{PDF} ha de ser integrable en la región del domino de las variables a ser optimizadas para garantizar que se pueda buscar valores en todo el espacio de búsqueda $\mathbb{X}$:

Por lo cual, un individuo cuántico puede ser representado de esta manera:

\begin{equation}
 q_i=\{q_{i1}=p_{i1}(x),q_{i2}=p_{i2}(x),...,q_{in}=p_{in}(x)\}
\end{equation}

Se puede utilizar una distribución uniforme $\text{U}_{ij}(x) \in [l_{ij},u_{ij}\rangle$ como \ac{PDF} al definirla como:

\begin{equation}
 p_{ij}(x)=\begin{cases}
         \cfrac{1}{u_{ij}-l_{ij}} & \text{if } l_{ij} \leq x \leq u_{ij} \\
         0 & \text{else }
        \end{cases}
\end{equation}

donde $u_{ij}$ es el límite superior y $l_{ij}$ el límite inferior del intervalo para el gen cuántico $q_{ij}$ al colapsar su superposición de estados al ser observado. La definición $\text{U}_{ij}(x)$ respeta la normalización requerida para la \ac{PDF} y es fácilmente implementable con una función que genere número aleatorios escalada al intervalo $[l_{ij},u_{ij}\rangle$ tal como $\text{U}_{ij}(x)=l_{ij}+(u_{ij}-l_{ij})\text{U}(x)$ donde $\text{U}(x)$ es un generador de números aleatorios reales en $[0,1\rangle$.

Cada individuo cuántico $q_i$ perteneciente a una población cuántica $\text{Q}_0$ poseería entonces $n$ genes cuántico $q_{ij}$, cada cual representado de dos formas posibles: ya sea por los valores $l_{ij},u_{ij}$ o por el centro $\mu_{ij}=\cfrac{l_{ij}+u_{ij}}{2}$ mas el ancho de pulso $\sigma_{ij}=u_{ij}-l_{ij}$. Ambas representaciones son equivalentes, por lo que un individuo cuántico $q_i=\{q_{i1},q_{i2}\}$ con pulsos de ancho $2$ y centros posicionados en $-0.5$ y $0.5$ sería representado por $q_i=\{\mu_{i1}=-0.5,\mu_{i2}=0.5,\sigma_{i1}=2,\sigma_{i2}=2\}$. 

Al realizar la observación de los individuos clásicos a partir de los individuos cuánticos, por lo general en cada iteración se hace una observación de únicamente uno por cada cual por iteración. Esta regla no es fija, por lo que se pueden realizar más observaciones por cada individuo cuántico, manteniendo especial cuidado en no mostrar sesgo por algún $q_i$ en especial para que la generación por individuo cuántico permanezca equitativa. De tal manera, para un valor $m$ que equivale al tamaño de población de individuos cuánticos, el total de individuos generados por iteración debería ser de $m_c \leq km$ donde $k \in \mathbb{N}$ y $m_c \leq m$.

Como se trata de un algoritmo evolutivo después de todo, es posible implementar operadores tales como recombinación, mutación, etc. La recombinación se da a nivel generaciones de individuos clásicos, donde un individuo objetivo puede surgir a partir de la combinación de características de un individuo almacenado con uno recién generado. Asimismo, se puede implementar operadores de mutación, aunque por el efecto \textit{exploring} que presenta la propia generación de los individuos clásicos mediante la observación, este no se considera necesario \cite{da2007algoritmos}.

En el momento de la selección de la nueva población clásica $X_t$, también se debe seleccionar la estrategia ideal para reemplazar $X_{t-1}$ por $X_t$, donde se puede considerar las siguientes opciones:
\begin{itemize}
 \item Estrategia extintiva: reemplazar completamente $X_{t-1}$ por $X_t$.
 \item Elitismo: similar a la estrategia extintiva, pero manteniendo el mejor elemento en $X_{t-1}$.
 \item \textit{Steady state}: reemplazar los $k$ mejores elementos en $X_t$ por los k peores en $X_{t-1}$.
 \item Estrategia$(\mu +\lambda)$-EE: reemplazar los $\lambda$ elementos de $X_{t-1}$ por los $\lambda$ mejores elementos de la unión $X_{t-1} \cup X_t$.
\end{itemize}

Para realizar la actualización de la población cuántica tras obtener la población clásica $X_t$, hay dos posibilidades que se pueden tomar en consideración: actualizar el espacio de búsqueda mediante la modificación del ancho de los pulsos, y modificar la posición del centro de los pulsos para ajustarlos a los individuos de la población clásica. Con esto se busca detectar las regiones más promisorias de $\mathbb{X}$.

Al ajustar el ancho de los pulsos, se puede emplear decaimiento exponencial o lineal para la alteración de los mismos, o también utilizar la ``regla del 1/5'', donde se aumenta la anchura por $\sigma$ si menos de 1/5 o 20\% de la población $X_t$ ofrece mejor evaluación que $X_{t-1}$, y se aumenta en caso contrario. Cabe mencionar que $\sigma \in \langle0,1\rangle$. 

De forma similar, al momento de actualizar los centros de los pulsos, se puede escoger mediante aleatoriamente, elitistamente o mediante un criterio proporcional cuáles individuos clásicos serán utilizados para actualizar los pulsos de la población cuántica $Q_t =\{q_i\}^n_{i=1}$, pero necesariamente tienen que escogerse $n$ individuos clásicos. Se puede utilizar la siguiente combinación convexa para definir el impacto en la población cuántica:

\begin{equation}
 \mu_{ij}(t+1)=\mu_{ij}(t)+\lambda(\mu_{ij}(t)-x_{ij}(t)), \lambda \in [0,1]
\end{equation}


\section{Consideraciones Finales}

Según se ha visto, el algoritmo \ac{QIEA}-$\mathbb{B}$ original es sencillo y de implementación relativamente rápida, mientras que el algoritmo para $\mathbb{R}$ sube ligeramente el listón en términos de inspiración pero añadiendo nuevas capacidades a las posibilidades de la inspiración cuántica. Se tomará este algoritmo como punto de partida para la propuesta que se desarrolla en el siguiente capítulo, el cual busca introducir tanto un aislamiento en el entorno de evolución de los individuos cuánticos, así como un nuevo mecanismo de recombinación que trabaje a nivel de individuos cuánticos.

