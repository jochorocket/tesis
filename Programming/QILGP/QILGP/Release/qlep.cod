; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\Users\Douglas\Documents\My Dropbox\QILGP_Develop\QILGP\qlep.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp___time64:PROC
PUBLIC	_SetEvolution
; Function compile flags: /Odtp
; File c:\users\douglas\documents\my dropbox\qilgp_develop\qilgp\qlep.c
_TEXT	SEGMENT
__lGateStep$ = 8					; size = 8
__popSize$ = 16						; size = 4
__nDemes$ = 20						; size = 4
__nCycles$ = 24						; size = 4
__nGenerations$ = 28					; size = 4
__generationsFreq$ = 32					; size = 4
__nExperiments$ = 36					; size = 4
_SetEvolution PROC

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 173  : 	lGateStep = _lGateStep;

  00003	dd 45 08	 fld	 QWORD PTR __lGateStep$[ebp]
  00006	dd 1d 00 00 00
	00		 fstp	 QWORD PTR _lGateStep

; 174  : 	popSize = _popSize;

  0000c	8b 45 10	 mov	 eax, DWORD PTR __popSize$[ebp]
  0000f	a3 00 00 00 00	 mov	 DWORD PTR _popSize, eax

; 175  : 	nDemes = _nDemes;

  00014	8b 4d 14	 mov	 ecx, DWORD PTR __nDemes$[ebp]
  00017	89 0d 00 00 00
	00		 mov	 DWORD PTR _nDemes, ecx

; 176  : 	nCycles = _nCycles;

  0001d	8b 55 18	 mov	 edx, DWORD PTR __nCycles$[ebp]
  00020	89 15 00 00 00
	00		 mov	 DWORD PTR _nCycles, edx

; 177  : 	nGenerations = _nGenerations;

  00026	8b 45 1c	 mov	 eax, DWORD PTR __nGenerations$[ebp]
  00029	a3 00 00 00 00	 mov	 DWORD PTR _nGenerations, eax

; 178  : 	generationsFreq = _generationsFreq;

  0002e	8b 4d 20	 mov	 ecx, DWORD PTR __generationsFreq$[ebp]
  00031	89 0d 00 00 00
	00		 mov	 DWORD PTR _generationsFreq, ecx

; 179  : 	nExperiments = _nExperiments;

  00037	8b 55 24	 mov	 edx, DWORD PTR __nExperiments$[ebp]
  0003a	89 15 00 00 00
	00		 mov	 DWORD PTR _nExperiments, edx

; 180  : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_SetEvolution ENDP
_TEXT	ENDS
PUBLIC	_SetIndiv
; Function compile flags: /Odtp
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
__header$ = 8						; size = 4
__headerLen$ = 12					; size = 1
__footer$ = 16						; size = 4
__footerLen$ = 20					; size = 1
_SetIndiv PROC

; 84   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	83 ec 08	 sub	 esp, 8

; 85   : 	int i, j;
; 86   : 	
; 87   : 	headerLen = _headerLen;

  00056	8a 45 0c	 mov	 al, BYTE PTR __headerLen$[ebp]
  00059	a2 00 00 00 00	 mov	 BYTE PTR _headerLen, al

; 88   : 	footerLen = _footerLen;

  0005e	8a 4d 14	 mov	 cl, BYTE PTR __footerLen$[ebp]
  00061	88 0d 00 00 00
	00		 mov	 BYTE PTR _footerLen, cl

; 89   : 
; 90   : 	header = malloc(headerLen * sizeof(byte));

  00067	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _headerLen
  0006e	52		 push	 edx
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00075	83 c4 04	 add	 esp, 4
  00078	a3 00 00 00 00	 mov	 DWORD PTR _header, eax

; 91   : 	for (i = 0; i < headerLen; i++)

  0007d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00084	eb 09		 jmp	 SHORT $LN6@SetIndiv
$LN5@SetIndiv:
  00086	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00089	83 c0 01	 add	 eax, 1
  0008c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@SetIndiv:
  0008f	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _headerLen
  00096	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  00099	7d 15		 jge	 SHORT $LN4@SetIndiv

; 92   : 	{
; 93   : 		header[i] = _header[i];

  0009b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _header
  000a1	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000a4	8b 45 08	 mov	 eax, DWORD PTR __header$[ebp]
  000a7	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000aa	8a 08		 mov	 cl, BYTE PTR [eax]
  000ac	88 0a		 mov	 BYTE PTR [edx], cl

; 94   : 	}

  000ae	eb d6		 jmp	 SHORT $LN5@SetIndiv
$LN4@SetIndiv:

; 95   : 
; 96   : 	footer = malloc(footerLen * sizeof(byte));

  000b0	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _footerLen
  000b7	52		 push	 edx
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000be	83 c4 04	 add	 esp, 4
  000c1	a3 00 00 00 00	 mov	 DWORD PTR _footer, eax

; 97   : 	for (j = 0; j< footerLen; j++)

  000c6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000cd	eb 09		 jmp	 SHORT $LN3@SetIndiv
$LN2@SetIndiv:
  000cf	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  000d2	83 c0 01	 add	 eax, 1
  000d5	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN3@SetIndiv:
  000d8	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _footerLen
  000df	39 4d f8	 cmp	 DWORD PTR _j$[ebp], ecx
  000e2	7d 15		 jge	 SHORT $LN7@SetIndiv

; 98   : 	{
; 99   : 		footer[j] = _footer[j];

  000e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _footer
  000ea	03 55 f8	 add	 edx, DWORD PTR _j$[ebp]
  000ed	8b 45 10	 mov	 eax, DWORD PTR __footer$[ebp]
  000f0	03 45 f8	 add	 eax, DWORD PTR _j$[ebp]
  000f3	8a 08		 mov	 cl, BYTE PTR [eax]
  000f5	88 0a		 mov	 BYTE PTR [edx], cl

; 100  : 	}

  000f7	eb d6		 jmp	 SHORT $LN2@SetIndiv
$LN7@SetIndiv:

; 101  : 
; 102  : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
_SetIndiv ENDP
_TEXT	ENDS
PUBLIC	_SetQIndiv
; Function compile flags: /Odtp
_TEXT	SEGMENT
_len$ = -8						; size = 4
_i$ = -4						; size = 4
__qIndivLen$ = 8					; size = 4
__qNopProb$ = 12					; size = 8
__nFuncs$ = 20						; size = 1
__termsDim$ = 24					; size = 1
__termsCardins$ = 28					; size = 4
__termIdxs$ = 32					; size = 4
__destReg0$ = 36					; size = 4
__typedTerms$ = 40					; size = 1
__effObserving$ = 44					; size = 1
__mCodesLens$ = 48					; size = 4
__mCodeDim$ = 52					; size = 1
__mCodeTable$ = 56					; size = 4
_SetQIndiv PROC

; 28   : {

  00100	55		 push	 ebp
  00101	8b ec		 mov	 ebp, esp
  00103	83 ec 08	 sub	 esp, 8

; 29   : 	int i;
; 30   : 	int len;
; 31   : 
; 32   : 	qIndivLen = _qIndivLen;

  00106	8b 45 08	 mov	 eax, DWORD PTR __qIndivLen$[ebp]
  00109	a3 00 00 00 00	 mov	 DWORD PTR _qIndivLen, eax

; 33   : 	qNopProb = _qNopProb;

  0010e	dd 45 0c	 fld	 QWORD PTR __qNopProb$[ebp]
  00111	dd 1d 00 00 00
	00		 fstp	 QWORD PTR _qNopProb

; 34   : 	nFuncs = _nFuncs;

  00117	8a 4d 14	 mov	 cl, BYTE PTR __nFuncs$[ebp]
  0011a	88 0d 00 00 00
	00		 mov	 BYTE PTR _nFuncs, cl

; 35   : 	termsDim = _termsDim;

  00120	8a 55 18	 mov	 dl, BYTE PTR __termsDim$[ebp]
  00123	88 15 00 00 00
	00		 mov	 BYTE PTR _termsDim, dl

; 36   : 	typedTerms = _typedTerms;

  00129	8a 45 28	 mov	 al, BYTE PTR __typedTerms$[ebp]
  0012c	a2 00 00 00 00	 mov	 BYTE PTR _typedTerms, al

; 37   : 	effObserving = _effObserving;

  00131	8a 4d 2c	 mov	 cl, BYTE PTR __effObserving$[ebp]
  00134	88 0d 00 00 00
	00		 mov	 BYTE PTR _effObserving, cl

; 38   : 	mCodeDim = _mCodeDim;

  0013a	8a 55 34	 mov	 dl, BYTE PTR __mCodeDim$[ebp]
  0013d	88 15 00 00 00
	00		 mov	 BYTE PTR _mCodeDim, dl

; 39   : 	qIndivInitLen = 8;

  00143	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR _qIndivInitLen, 8

; 40   : 
; 41   : 	destReg0 = malloc(nFuncs * sizeof(byte));

  0014d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _nFuncs
  00154	50		 push	 eax
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0015b	83 c4 04	 add	 esp, 4
  0015e	a3 00 00 00 00	 mov	 DWORD PTR _destReg0, eax

; 42   : 	for (i = 0; i < nFuncs; i++)

  00163	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0016a	eb 09		 jmp	 SHORT $LN16@SetQIndiv
$LN15@SetQIndiv:
  0016c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0016f	83 c1 01	 add	 ecx, 1
  00172	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN16@SetQIndiv:
  00175	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _nFuncs
  0017c	39 55 fc	 cmp	 DWORD PTR _i$[ebp], edx
  0017f	7d 14		 jge	 SHORT $LN14@SetQIndiv

; 43   : 	{
; 44   : 		destReg0[i] = _destReg0[i];

  00181	a1 00 00 00 00	 mov	 eax, DWORD PTR _destReg0
  00186	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00189	8b 4d 24	 mov	 ecx, DWORD PTR __destReg0$[ebp]
  0018c	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0018f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00191	88 10		 mov	 BYTE PTR [eax], dl

; 45   : 	}

  00193	eb d7		 jmp	 SHORT $LN15@SetQIndiv
$LN14@SetQIndiv:

; 46   : 
; 47   : 	termsCardins = malloc(nFuncs * sizeof(byte));

  00195	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _nFuncs
  0019c	50		 push	 eax
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  001a3	83 c4 04	 add	 esp, 4
  001a6	a3 00 00 00 00	 mov	 DWORD PTR _termsCardins, eax

; 48   : 	for (i = 0; i < nFuncs; i++)

  001ab	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001b2	eb 09		 jmp	 SHORT $LN13@SetQIndiv
$LN12@SetQIndiv:
  001b4	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001b7	83 c1 01	 add	 ecx, 1
  001ba	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN13@SetQIndiv:
  001bd	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _nFuncs
  001c4	39 55 fc	 cmp	 DWORD PTR _i$[ebp], edx
  001c7	7d 14		 jge	 SHORT $LN11@SetQIndiv

; 49   : 	{
; 50   : 		termsCardins[i] = _termsCardins[i];

  001c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _termsCardins
  001ce	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  001d1	8b 4d 1c	 mov	 ecx, DWORD PTR __termsCardins$[ebp]
  001d4	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  001d7	8a 11		 mov	 dl, BYTE PTR [ecx]
  001d9	88 10		 mov	 BYTE PTR [eax], dl

; 51   : 	}

  001db	eb d7		 jmp	 SHORT $LN12@SetQIndiv
$LN11@SetQIndiv:

; 52   : 
; 53   : 	if (_termIdxs != NULL)

  001dd	83 7d 20 00	 cmp	 DWORD PTR __termIdxs$[ebp], 0
  001e1	74 48		 je	 SHORT $LN7@SetQIndiv

; 54   : 	{
; 55   : 		termIdxs = malloc(nFuncs * sizeof(byte));

  001e3	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _nFuncs
  001ea	50		 push	 eax
  001eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  001f1	83 c4 04	 add	 esp, 4
  001f4	a3 00 00 00 00	 mov	 DWORD PTR _termIdxs, eax

; 56   : 		for (i = 0; i < nFuncs; i++)

  001f9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00200	eb 09		 jmp	 SHORT $LN9@SetQIndiv
$LN8@SetQIndiv:
  00202	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00205	83 c1 01	 add	 ecx, 1
  00208	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN9@SetQIndiv:
  0020b	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _nFuncs
  00212	39 55 fc	 cmp	 DWORD PTR _i$[ebp], edx
  00215	7d 14		 jge	 SHORT $LN7@SetQIndiv

; 57   : 		{
; 58   : 			termIdxs[i] = _termIdxs[i];

  00217	a1 00 00 00 00	 mov	 eax, DWORD PTR _termIdxs
  0021c	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0021f	8b 4d 20	 mov	 ecx, DWORD PTR __termIdxs$[ebp]
  00222	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00225	8a 11		 mov	 dl, BYTE PTR [ecx]
  00227	88 10		 mov	 BYTE PTR [eax], dl

; 59   : 		}

  00229	eb d7		 jmp	 SHORT $LN8@SetQIndiv
$LN7@SetQIndiv:

; 60   : 	}
; 61   : 
; 62   : 	len = nFuncs * termsDim;

  0022b	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _nFuncs
  00232	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _termsDim
  00239	0f af c1	 imul	 eax, ecx
  0023c	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 63   : 	mCodesLens = malloc(len * sizeof(byte));

  0023f	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  00242	52		 push	 edx
  00243	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00249	83 c4 04	 add	 esp, 4
  0024c	a3 00 00 00 00	 mov	 DWORD PTR _mCodesLens, eax

; 64   : 	for (i = 0; i < len; i++)

  00251	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00258	eb 09		 jmp	 SHORT $LN6@SetQIndiv
$LN5@SetQIndiv:
  0025a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0025d	83 c0 01	 add	 eax, 1
  00260	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@SetQIndiv:
  00263	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00266	3b 4d f8	 cmp	 ecx, DWORD PTR _len$[ebp]
  00269	7d 15		 jge	 SHORT $LN4@SetQIndiv

; 65   : 	{
; 66   : 		mCodesLens[i] = _mCodesLens[i];

  0026b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _mCodesLens
  00271	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00274	8b 45 30	 mov	 eax, DWORD PTR __mCodesLens$[ebp]
  00277	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0027a	8a 08		 mov	 cl, BYTE PTR [eax]
  0027c	88 0a		 mov	 BYTE PTR [edx], cl

; 67   : 	}

  0027e	eb da		 jmp	 SHORT $LN5@SetQIndiv
$LN4@SetQIndiv:

; 68   : 
; 69   : 	len *= mCodeDim;

  00280	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _mCodeDim
  00287	0f af 55 f8	 imul	 edx, DWORD PTR _len$[ebp]
  0028b	89 55 f8	 mov	 DWORD PTR _len$[ebp], edx

; 70   : 	mCodeTable = malloc(len * sizeof(byte));

  0028e	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00291	50		 push	 eax
  00292	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00298	83 c4 04	 add	 esp, 4
  0029b	a3 00 00 00 00	 mov	 DWORD PTR _mCodeTable, eax

; 71   : 	for (i = 0; i < len; i++)

  002a0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  002a7	eb 09		 jmp	 SHORT $LN3@SetQIndiv
$LN2@SetQIndiv:
  002a9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  002ac	83 c1 01	 add	 ecx, 1
  002af	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN3@SetQIndiv:
  002b2	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  002b5	3b 55 f8	 cmp	 edx, DWORD PTR _len$[ebp]
  002b8	7d 14		 jge	 SHORT $LN1@SetQIndiv

; 72   : 	{
; 73   : 		mCodeTable[i] = _mCodeTable[i];

  002ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _mCodeTable
  002bf	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  002c2	8b 4d 38	 mov	 ecx, DWORD PTR __mCodeTable$[ebp]
  002c5	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  002c8	8a 11		 mov	 dl, BYTE PTR [ecx]
  002ca	88 10		 mov	 BYTE PTR [eax], dl

; 74   : 	}

  002cc	eb db		 jmp	 SHORT $LN2@SetQIndiv
$LN1@SetQIndiv:

; 75   : 
; 76   : 	return nFuncs;

  002ce	a0 00 00 00 00	 mov	 al, BYTE PTR _nFuncs

; 77   : }

  002d3	8b e5		 mov	 esp, ebp
  002d5	5d		 pop	 ebp
  002d6	c3		 ret	 0
_SetQIndiv ENDP
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\time.inl
__Time$ = 8						; size = 4
_time	PROC

; 134  : {

  002e0	55		 push	 ebp
  002e1	8b ec		 mov	 ebp, esp

; 135  :     return _time64(_Time);

  002e3	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  002e6	50		 push	 eax
  002e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  002ed	83 c4 04	 add	 esp, 4

; 136  : }

  002f0	5d		 pop	 ebp
  002f1	c3		 ret	 0
_time	ENDP
PUBLIC	_SetInputCases
; Function compile flags: /Odtp
; File c:\users\douglas\documents\my dropbox\qilgp_develop\qilgp\qlep.c
_TEXT	SEGMENT
_len$ = -8						; size = 4
_i$ = -4						; size = 4
__classifProb$ = 8					; size = 1
__trainingData$ = 12					; size = 4
__validatingData$ = 16					; size = 4
__testingData$ = 20					; size = 4
__nSamplesTrain$ = 24					; size = 4
__nSamplesValid$ = 28					; size = 4
__nSamplesTest$ = 32					; size = 4
__dataRowDim$ = 36					; size = 4
__consts$ = 40						; size = 4
__nConsts$ = 44						; size = 4
_SetInputCases PROC

; 115  : {

  00300	55		 push	 ebp
  00301	8b ec		 mov	 ebp, esp
  00303	83 ec 08	 sub	 esp, 8

; 116  : 	int i;
; 117  : 	int len;
; 118  : 
; 119  : 	classifProb = _classifProb;

  00306	8a 45 08	 mov	 al, BYTE PTR __classifProb$[ebp]
  00309	a2 00 00 00 00	 mov	 BYTE PTR _classifProb, al

; 120  : 	nSamplesTrain = _nSamplesTrain;

  0030e	8b 4d 18	 mov	 ecx, DWORD PTR __nSamplesTrain$[ebp]
  00311	89 0d 00 00 00
	00		 mov	 DWORD PTR _nSamplesTrain, ecx

; 121  : 	nSamplesValid = _nSamplesValid;

  00317	8b 55 1c	 mov	 edx, DWORD PTR __nSamplesValid$[ebp]
  0031a	89 15 00 00 00
	00		 mov	 DWORD PTR _nSamplesValid, edx

; 122  : 	nSamplesTest = _nSamplesTest;

  00320	8b 45 20	 mov	 eax, DWORD PTR __nSamplesTest$[ebp]
  00323	a3 00 00 00 00	 mov	 DWORD PTR _nSamplesTest, eax

; 123  : 	dataRowDim = _dataRowDim;

  00328	8b 4d 24	 mov	 ecx, DWORD PTR __dataRowDim$[ebp]
  0032b	89 0d 00 00 00
	00		 mov	 DWORD PTR _dataRowDim, ecx

; 124  : 	nConsts = _nConsts;

  00331	8b 55 2c	 mov	 edx, DWORD PTR __nConsts$[ebp]
  00334	89 15 00 00 00
	00		 mov	 DWORD PTR _nConsts, edx

; 125  : 	nVars = dataRowDim - 1;

  0033a	a1 00 00 00 00	 mov	 eax, DWORD PTR _dataRowDim
  0033f	83 e8 01	 sub	 eax, 1
  00342	a3 00 00 00 00	 mov	 DWORD PTR _nVars, eax

; 126  : 
; 127  : 	len = nSamplesTrain * dataRowDim;

  00347	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nSamplesTrain
  0034d	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR _dataRowDim
  00354	89 4d f8	 mov	 DWORD PTR _len$[ebp], ecx

; 128  : 
; 129  : 	trainingData = malloc(len * sizeof(double));

  00357	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  0035a	c1 e2 03	 shl	 edx, 3
  0035d	52		 push	 edx
  0035e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00364	83 c4 04	 add	 esp, 4
  00367	a3 00 00 00 00	 mov	 DWORD PTR _trainingData, eax

; 130  : 	for (i = 0; i < len; i++)

  0036c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00373	eb 09		 jmp	 SHORT $LN14@SetInputCa
$LN13@SetInputCa:
  00375	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00378	83 c0 01	 add	 eax, 1
  0037b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN14@SetInputCa:
  0037e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00381	3b 4d f8	 cmp	 ecx, DWORD PTR _len$[ebp]
  00384	7d 17		 jge	 SHORT $LN12@SetInputCa

; 131  : 	{
; 132  : 		trainingData[i] = _trainingData[i];

  00386	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00389	8b 45 0c	 mov	 eax, DWORD PTR __trainingData$[ebp]
  0038c	dd 04 d0	 fld	 QWORD PTR [eax+edx*8]
  0038f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00392	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _trainingData
  00398	d9 1c 8a	 fstp	 DWORD PTR [edx+ecx*4]

; 133  : 	}

  0039b	eb d8		 jmp	 SHORT $LN13@SetInputCa
$LN12@SetInputCa:

; 134  : 
; 135  : 	if (_validatingData)

  0039d	83 7d 10 00	 cmp	 DWORD PTR __validatingData$[ebp], 0
  003a1	74 55		 je	 SHORT $LN8@SetInputCa

; 136  : 	{
; 137  : 		len = nSamplesValid * dataRowDim;

  003a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _nSamplesValid
  003a8	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _dataRowDim
  003af	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 138  : 		validatingData = malloc(len * sizeof(double));

  003b2	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  003b5	c1 e1 03	 shl	 ecx, 3
  003b8	51		 push	 ecx
  003b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  003bf	83 c4 04	 add	 esp, 4
  003c2	a3 00 00 00 00	 mov	 DWORD PTR _validatingData, eax

; 139  : 		for (i = 0; i < len; i++)

  003c7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  003ce	eb 09		 jmp	 SHORT $LN10@SetInputCa
$LN9@SetInputCa:
  003d0	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  003d3	83 c2 01	 add	 edx, 1
  003d6	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN10@SetInputCa:
  003d9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003dc	3b 45 f8	 cmp	 eax, DWORD PTR _len$[ebp]
  003df	7d 17		 jge	 SHORT $LN8@SetInputCa

; 140  : 		{
; 141  : 			validatingData[i] = _validatingData[i];

  003e1	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  003e4	8b 55 10	 mov	 edx, DWORD PTR __validatingData$[ebp]
  003e7	dd 04 ca	 fld	 QWORD PTR [edx+ecx*8]
  003ea	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validatingData
  003f3	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 142  : 		}

  003f6	eb d8		 jmp	 SHORT $LN9@SetInputCa
$LN8@SetInputCa:

; 143  : 	}
; 144  : 
; 145  : 	if (_testingData)

  003f8	83 7d 14 00	 cmp	 DWORD PTR __testingData$[ebp], 0
  003fc	74 55		 je	 SHORT $LN4@SetInputCa

; 146  : 	{
; 147  : 		len = nSamplesTest * dataRowDim;

  003fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nSamplesTest
  00404	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR _dataRowDim
  0040b	89 55 f8	 mov	 DWORD PTR _len$[ebp], edx

; 148  : 		testingData = malloc(len * sizeof(double));

  0040e	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00411	c1 e0 03	 shl	 eax, 3
  00414	50		 push	 eax
  00415	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0041b	83 c4 04	 add	 esp, 4
  0041e	a3 00 00 00 00	 mov	 DWORD PTR _testingData, eax

; 149  : 		for (i = 0; i < len; i++)

  00423	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0042a	eb 09		 jmp	 SHORT $LN6@SetInputCa
$LN5@SetInputCa:
  0042c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0042f	83 c1 01	 add	 ecx, 1
  00432	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN6@SetInputCa:
  00435	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00438	3b 55 f8	 cmp	 edx, DWORD PTR _len$[ebp]
  0043b	7d 16		 jge	 SHORT $LN4@SetInputCa

; 150  : 		{
; 151  : 			testingData[i] = _testingData[i];

  0043d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00440	8b 4d 14	 mov	 ecx, DWORD PTR __testingData$[ebp]
  00443	dd 04 c1	 fld	 QWORD PTR [ecx+eax*8]
  00446	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00449	a1 00 00 00 00	 mov	 eax, DWORD PTR _testingData
  0044e	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 152  : 		}

  00451	eb d9		 jmp	 SHORT $LN5@SetInputCa
$LN4@SetInputCa:

; 153  : 	}
; 154  : 
; 155  : 	consts = malloc(nConsts * sizeof(double));

  00453	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nConsts
  00459	c1 e1 03	 shl	 ecx, 3
  0045c	51		 push	 ecx
  0045d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00463	83 c4 04	 add	 esp, 4
  00466	a3 00 00 00 00	 mov	 DWORD PTR _consts, eax

; 156  : 	for (i = 0; i < nConsts; i++)

  0046b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00472	eb 09		 jmp	 SHORT $LN3@SetInputCa
$LN2@SetInputCa:
  00474	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00477	83 c2 01	 add	 edx, 1
  0047a	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN3@SetInputCa:
  0047d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00480	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nConsts
  00486	7d 17		 jge	 SHORT $LN1@SetInputCa

; 157  : 	{
; 158  : 		consts[i] = _consts[i];

  00488	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0048b	8b 55 28	 mov	 edx, DWORD PTR __consts$[ebp]
  0048e	dd 04 ca	 fld	 QWORD PTR [edx+ecx*8]
  00491	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00494	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _consts
  0049a	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 159  : 	}

  0049d	eb d5		 jmp	 SHORT $LN2@SetInputCa
$LN1@SetInputCa:

; 160  : 
; 161  : 	InitCaseVector();

  0049f	e8 00 00 00 00	 call	 _InitCaseVector

; 162  : }

  004a4	8b e5		 mov	 esp, ebp
  004a6	5d		 pop	 ebp
  004a7	c3		 ret	 0
_SetInputCases ENDP
PUBLIC	_RunQLEP
; Function compile flags: /Odtp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_RunQLEP PROC

; 184  : {

  004b0	55		 push	 ebp
  004b1	8b ec		 mov	 ebp, esp
  004b3	51		 push	 ecx

; 185  : 	unsigned int i;
; 186  : 	//srand((unsigned int)time(NULL));
; 187  : 	//srand(1);
; 188  : 	init_genrand((unsigned long)time(NULL));

  004b4	6a 00		 push	 0
  004b6	e8 00 00 00 00	 call	 _time
  004bb	83 c4 04	 add	 esp, 4
  004be	50		 push	 eax
  004bf	e8 00 00 00 00	 call	 _init_genrand
  004c4	83 c4 04	 add	 esp, 4

; 189  : 	//init_genrand(1);
; 190  : 
; 191  : 	writeFreq = nGenerations / 100;

  004c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _nGenerations
  004cc	33 d2		 xor	 edx, edx
  004ce	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  004d3	f7 f1		 div	 ecx
  004d5	a3 00 00 00 00	 mov	 DWORD PTR _writeFreq, eax

; 192  : 	indivLen = (headerLen + qIndivLen * mCodeDim + footerLen);

  004da	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _headerLen
  004e1	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _mCodeDim
  004e8	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _qIndivLen
  004ef	03 d0		 add	 edx, eax
  004f1	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _footerLen
  004f8	03 d1		 add	 edx, ecx
  004fa	89 15 00 00 00
	00		 mov	 DWORD PTR _indivLen, edx

; 193  : 	InitSintaticTable();

  00500	e8 00 00 00 00	 call	 _InitSintaticTable

; 194  : 	InitIndiv();

  00505	e8 00 00 00 00	 call	 _InitIndiv

; 195  : 
; 196  : 	accumFit = malloc(nGenerations / writeFreq * sizeof(double));

  0050a	a1 00 00 00 00	 mov	 eax, DWORD PTR _nGenerations
  0050f	33 d2		 xor	 edx, edx
  00511	f7 35 00 00 00
	00		 div	 DWORD PTR _writeFreq
  00517	c1 e0 03	 shl	 eax, 3
  0051a	50		 push	 eax
  0051b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00521	83 c4 04	 add	 esp, 4
  00524	a3 00 00 00 00	 mov	 DWORD PTR _accumFit, eax

; 197  : 	accumValFit = malloc(nGenerations / writeFreq * sizeof(double));

  00529	a1 00 00 00 00	 mov	 eax, DWORD PTR _nGenerations
  0052e	33 d2		 xor	 edx, edx
  00530	f7 35 00 00 00
	00		 div	 DWORD PTR _writeFreq
  00536	c1 e0 03	 shl	 eax, 3
  00539	50		 push	 eax
  0053a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00540	83 c4 04	 add	 esp, 4
  00543	a3 00 00 00 00	 mov	 DWORD PTR _accumValFit, eax

; 198  : 	accumLen = malloc(nGenerations / writeFreq * sizeof(double));

  00548	a1 00 00 00 00	 mov	 eax, DWORD PTR _nGenerations
  0054d	33 d2		 xor	 edx, edx
  0054f	f7 35 00 00 00
	00		 div	 DWORD PTR _writeFreq
  00555	c1 e0 03	 shl	 eax, 3
  00558	50		 push	 eax
  00559	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0055f	83 c4 04	 add	 esp, 4
  00562	a3 00 00 00 00	 mov	 DWORD PTR _accumLen, eax

; 199  : 	for (i = 0; i < (nGenerations / writeFreq); i++)

  00567	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0056e	eb 09		 jmp	 SHORT $LN3@RunQLEP
$LN2@RunQLEP:
  00570	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00573	83 c2 01	 add	 edx, 1
  00576	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN3@RunQLEP:
  00579	a1 00 00 00 00	 mov	 eax, DWORD PTR _nGenerations
  0057e	33 d2		 xor	 edx, edx
  00580	f7 35 00 00 00
	00		 div	 DWORD PTR _writeFreq
  00586	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  00589	73 2d		 jae	 SHORT $LN1@RunQLEP

; 200  : 	{
; 201  : 		accumFit[i] = 0;

  0058b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0058e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _accumFit
  00594	d9 ee		 fldz
  00596	d9 1c 81	 fstp	 DWORD PTR [ecx+eax*4]

; 202  : 		accumValFit[i] = 0;

  00599	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0059c	a1 00 00 00 00	 mov	 eax, DWORD PTR _accumValFit
  005a1	d9 ee		 fldz
  005a3	d9 1c 90	 fstp	 DWORD PTR [eax+edx*4]

; 203  : 		accumLen[i] = 0;

  005a6	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  005a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumLen
  005af	c7 04 8a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx*4], 0

; 204  : 	}

  005b6	eb b8		 jmp	 SHORT $LN2@RunQLEP
$LN1@RunQLEP:

; 205  : 	nEvaluations = 0;

  005b8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nEvaluations, 0

; 206  : 
; 207  : 	bestTkIndiv.error = HUGE_VAL;

  005c2	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___HUGE
  005c7	dd 00		 fld	 QWORD PTR [eax]
  005c9	dd 1d 18 00 00
	00		 fstp	 QWORD PTR _bestTkIndiv+24

; 208  : 	bestTkIndiv.fitness = HUGE_VAL;

  005cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___HUGE
  005d5	dd 01		 fld	 QWORD PTR [ecx]
  005d7	dd 1d 08 00 00
	00		 fstp	 QWORD PTR _bestTkIndiv+8

; 209  : 	bestTkIndiv.validFitness = HUGE_VAL;

  005dd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp___HUGE
  005e3	dd 02		 fld	 QWORD PTR [edx]
  005e5	dd 1d 10 00 00
	00		 fstp	 QWORD PTR _bestTkIndiv+16

; 210  : 	bestTkIndiv.genome = malloc(qIndivLen * sizeof(int) * 2);

  005eb	a1 00 00 00 00	 mov	 eax, DWORD PTR _qIndivLen
  005f0	c1 e0 02	 shl	 eax, 2
  005f3	d1 e0		 shl	 eax, 1
  005f5	50		 push	 eax
  005f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  005fc	83 c4 04	 add	 esp, 4
  005ff	a3 00 00 00 00	 mov	 DWORD PTR _bestTkIndiv, eax

; 211  : 
; 212  : 	return RunMultiQLEP();

  00604	e8 00 00 00 00	 call	 _RunMultiQLEP

; 213  : }

  00609	8b e5		 mov	 esp, ebp
  0060b	5d		 pop	 ebp
  0060c	c3		 ret	 0
_RunQLEP ENDP
_TEXT	ENDS
END
