; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	D:\JOCHO\sanpa\seminario de tesis\QILGP\QILGP\evolution.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp___HUGE:QWORD
EXTRN	__imp__rand:PROC
$SG4294967163 DB 'trnOut.txt', 00H, 00H
$SG4294967162 DB 'vldOut.txt', 00H, 00H
$SG4294967161 DB 'tstOut.txt', 00H, 00H
$SG4294967160 DB 'w', 00H
	ORG $+2
$SG4294967159 DB 'hitsOut.txt', 00H
$SG4294967158 DB 'w', 00H
	ORG $+2
$SG4294967157 DB 'experimsOut.txt', 00H
$SG4294967156 DB 'Gen;', 09H, 00H
	ORG $+2
$SG4294967155 DB 'BestValidIndiv;', 09H, 00H
	ORG $+3
$SG4294967154 DB 'Len Train Valid;', 09H, 00H
	ORG $+2
$SG4294967153 DB 0aH, 00H
	ORG $+2
$SG4294967152 DB 'Experiment %d:', 0aH, 00H
$SG4294967151 DB 0aH, 0aH, 00H
	ORG $+1
$SG4294967150 DB 0aH, '#Evaluations = %d', 0aH, 00H
$SG4294967149 DB 'Best evolved individual:', 0aH, 00H
	ORG $+2
$SG4294967148 DB '  Length = %d', 0aH, 00H
	ORG $+1
$SG4294967147 DB '  Training error   = %g', 0aH, 00H
	ORG $+3
$SG4294967146 DB '  Validating error = %g', 0aH, 00H
	ORG $+3
$SG4294967145 DB '  Testing error    = %g', 0aH, 00H
	ORG $+3
$SG4294967144 DB '  Genotype: ', 00H
	ORG $+3
$SG4294967143 DB '%x,', 00H
$SG4294967142 DB '%x ', 00H
$SG4294967141 DB 'w', 00H
	ORG $+2
$SG4294967140 DB 'averageOut.txt', 00H
	ORG $+1
$SG4294967139 DB '%d %g %g %d', 0aH, 00H
	ORG $+3
$SG4294967138 DB '%d %g %d', 0aH, 00H
	ORG $+2
$SG4294967137 DB '%d %g %g %d', 0aH, 00H
	ORG $+3
$SG4294967136 DB '%d %g %d', 0aH, 00H
	ORG $+2
$SG4294967135 DB '%d;', 09H, 00H
	ORG $+3
$SG4294967134 DB '%d %g %g;', 09H, 00H
	ORG $+1
$SG4294967133 DB '%d %g %g;', 09H, 00H
	ORG $+1
$SG4294967132 DB 0aH, 'Programs evaluated=%d', 00H
	ORG $+1
$SG4294967131 DB 0aH, 'Best Program: T=%g; V=%g; L=%d', 0aH, 0aH, 00H
	ORG $+2
$SG4294967130 DB 'Best: Len=%d; Trn=%g; Val=%g; Tst=%g;', 0aH, 00H
	ORG $+1
$SG4294967129 DB '  Genotype: ', 00H
	ORG $+3
$SG4294967128 DB '%x,', 00H
$SG4294967127 DB '%x ', 00H
$SG4294967126 DB 0aH, 0aH, 00H
	ORG $+1
$SG4294967125 DB 'trainOut', 00H
	ORG $+3
$SG4294967124 DB 'validOut', 00H
	ORG $+3
$SG4294967123 DB 'testOut', 00H
$SG4294967122 DB 'G=%d RST!  ', 00H
$SG4294967121 DB 'G=%i L=%i T=%.4f BV=%.4f!  ', 00H
$SG4294967120 DB 'G=%i; ', 00H
	ORG $+1
$SG4294967119 DB 'G=%i L=%i T=%g;  ', 00H
	ORG $+2
$SG4294967118 DB 'D%d Rst;  ', 00H
	ORG $+1
$SG4294967117 DB 'D%i L=%i T=%.4f V=%.4f;  ', 00H
	ORG $+2
$SG4294967116 DB 'D%i L=%i;  ', 00H
$SG4294967115 DB '<= G=%i Best!  ', 00H
PUBLIC	_RunGenerationDemes
PUBLIC	_RunDeme
PUBLIC	_InitDemes
PUBLIC	_RunExperiment
PUBLIC	_RunMultiQILGP
?nTkIndivs@?1??RunMultiQILGP@@9@9 DD 01H DUP (?)	; `RunMultiQILGP'::`2'::nTkIndivs
?nTkIndivs@?1??RunDeme@@9@9 DD 01H DUP (?)		; `RunDeme'::`2'::nTkIndivs
?lastTkIndiv@?1??RunDeme@@9@9 DD 01H DUP (?)		; `RunDeme'::`2'::lastTkIndiv
?nTkIndivs@?1??InitDemes@@9@9 DD 01H DUP (?)		; `InitDemes'::`2'::nTkIndivs
_BSS	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\evolution.c
_TEXT	SEGMENT
tv531 = -72						; size = 8
tv510 = -64						; size = 8
tv506 = -56						; size = 4
tv169 = -52						; size = 4
tv527 = -48						; size = 4
_i$ = -44						; size = 4
_fileVldName$ = -40					; size = 12
_fileTrnName$ = -28					; size = 12
_fileTstName$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_RunMultiQILGP PROC

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 16   : 	unsigned int i;
; 17   : 	static unsigned int nTkIndivs;
; 18   : 	char fileTrnName[] = "trnOut.txt\0";

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG4294967163
  00015	89 45 e4	 mov	 DWORD PTR _fileTrnName$[ebp], eax
  00018	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG4294967163+4
  0001e	89 4d e8	 mov	 DWORD PTR _fileTrnName$[ebp+4], ecx
  00021	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR $SG4294967163+8
  00027	89 55 ec	 mov	 DWORD PTR _fileTrnName$[ebp+8], edx

; 19   : 	char fileVldName[] = "vldOut.txt\0";

  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG4294967162
  0002f	89 45 d8	 mov	 DWORD PTR _fileVldName$[ebp], eax
  00032	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG4294967162+4
  00038	89 4d dc	 mov	 DWORD PTR _fileVldName$[ebp+4], ecx
  0003b	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR $SG4294967162+8
  00041	89 55 e0	 mov	 DWORD PTR _fileVldName$[ebp+8], edx

; 20   : 	char fileTstName[] = "tstOut.txt\0";

  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG4294967161
  00049	89 45 f0	 mov	 DWORD PTR _fileTstName$[ebp], eax
  0004c	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG4294967161+4
  00052	89 4d f4	 mov	 DWORD PTR _fileTstName$[ebp+4], ecx
  00055	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR $SG4294967161+8
  0005b	89 55 f8	 mov	 DWORD PTR _fileTstName$[ebp+8], edx

; 21   : 
; 22   : 	bestFit = HUGE_VAL;

  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___HUGE
  00063	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00067	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _bestFit, xmm0

; 23   : 	nTkIndivs = 2 * popSize;

  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _popSize
  00075	d1 e1		 shl	 ecx, 1
  00077	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nTkIndivs@?1??RunMultiQILGP@@9@9, ecx

; 24   : 
; 25   : 	qTokenAux = InitQToken(8);

  0007d	6a 08		 push	 8
  0007f	e8 00 00 00 00	 call	 _InitQToken
  00084	83 c4 04	 add	 esp, 4
  00087	a3 00 00 00 00	 mov	 DWORD PTR _qTokenAux, eax
  0008c	89 15 04 00 00
	00		 mov	 DWORD PTR _qTokenAux+4, edx

; 26   : 
; 27   : 	// Allocate memory to the best individual of the current experiment
; 28   :     bestExpTkIndiv.genome = (byte*)malloc(qIndivLen * sizeof(int) * 2);

  00092	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _qIndivLen
  00098	c1 e2 02	 shl	 edx, 2
  0009b	d1 e2		 shl	 edx, 1
  0009d	52		 push	 edx
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000a4	83 c4 04	 add	 esp, 4
  000a7	a3 00 00 00 00	 mov	 DWORD PTR _bestExpTkIndiv, eax

; 29   : 
; 30   : 	// Allocate memory to the best individual of the QILGP's run (since then)
; 31   :     bestTkIndiv.genome = (byte*)malloc(qIndivLen * sizeof(int) * 2);

  000ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _qIndivLen
  000b1	c1 e0 02	 shl	 eax, 2
  000b4	d1 e0		 shl	 eax, 1
  000b6	50		 push	 eax
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000bd	83 c4 04	 add	 esp, 4
  000c0	a3 00 00 00 00	 mov	 DWORD PTR _bestTkIndiv, eax

; 32   : 
; 33   : 	// Allocate memory to token individuals population
; 34   : 	tkPop = malloc(nTkIndivs * sizeof(struct tkIndiv));

  000c5	6b 0d 00 00 00
	00 28		 imul	 ecx, DWORD PTR ?nTkIndivs@?1??RunMultiQILGP@@9@9, 40
  000cc	51		 push	 ecx
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000d3	83 c4 04	 add	 esp, 4
  000d6	a3 00 00 00 00	 mov	 DWORD PTR _tkPop, eax

; 35   : 	for (i = 0; i < nTkIndivs; i++)

  000db	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e2	eb 09		 jmp	 SHORT $LN31@RunMultiQI
$LN30@RunMultiQI:
  000e4	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  000e7	83 c2 01	 add	 edx, 1
  000ea	89 55 d4	 mov	 DWORD PTR _i$[ebp], edx
$LN31@RunMultiQI:
  000ed	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  000f0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?nTkIndivs@?1??RunMultiQILGP@@9@9
  000f6	73 72		 jae	 SHORT $LN29@RunMultiQI

; 36   : 	{
; 37   : 		tkPop[i].genome = malloc(2 * qIndivLen * sizeof(int));

  000f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _qIndivLen
  000fe	d1 e1		 shl	 ecx, 1
  00100	c1 e1 02	 shl	 ecx, 2
  00103	51		 push	 ecx
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0010a	83 c4 04	 add	 esp, 4
  0010d	6b 55 d4 28	 imul	 edx, DWORD PTR _i$[ebp], 40
  00111	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tkPop
  00117	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 38   : 		tkPop[i].error = HUGE_VAL;

  0011a	6b 55 d4 28	 imul	 edx, DWORD PTR _i$[ebp], 40
  0011e	a1 00 00 00 00	 mov	 eax, DWORD PTR _tkPop
  00123	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___HUGE
  00129	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  0012d	f2 0f 11 44 10
	18		 movsd	 QWORD PTR [eax+edx+24], xmm0

; 39   : 		tkPop[i].fitness = HUGE_VAL;

  00133	6b 55 d4 28	 imul	 edx, DWORD PTR _i$[ebp], 40
  00137	a1 00 00 00 00	 mov	 eax, DWORD PTR _tkPop
  0013c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___HUGE
  00142	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  00146	f2 0f 11 44 10
	08		 movsd	 QWORD PTR [eax+edx+8], xmm0

; 40   :         tkPop[i].validFitness = HUGE_VAL;

  0014c	6b 55 d4 28	 imul	 edx, DWORD PTR _i$[ebp], 40
  00150	a1 00 00 00 00	 mov	 eax, DWORD PTR _tkPop
  00155	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___HUGE
  0015b	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  0015f	f2 0f 11 44 10
	10		 movsd	 QWORD PTR [eax+edx+16], xmm0

; 41   : 	}

  00165	e9 7a ff ff ff	 jmp	 $LN30@RunMultiQI
$LN29@RunMultiQI:

; 42   : 
; 43   : 	// Allocate memory to quantum individuals population
; 44   : 	qPop = malloc(popSize * qIndivLen * sizeof(qGene));

  0016a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _popSize
  00170	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR _qIndivLen
  00177	6b c2 0c	 imul	 eax, edx, 12
  0017a	50		 push	 eax
  0017b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00181	83 c4 04	 add	 esp, 4
  00184	a3 00 00 00 00	 mov	 DWORD PTR _qPop, eax

; 45   : 
; 46   : 	extrons = malloc(qIndivLen * sizeof(byte));

  00189	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _qIndivLen
  0018f	51		 push	 ecx
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00196	83 c4 04	 add	 esp, 4
  00199	a3 00 00 00 00	 mov	 DWORD PTR _extrons, eax

; 47   : 
; 48   : 	if (!validatingData)

  0019e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _validatingData, 0
  001a5	75 18		 jne	 SHORT $LN28@RunMultiQI

; 49   : 	{
; 50   : 		hitsOut = fopen("hitsOut.txt", "w");

  001a7	68 00 00 00 00	 push	 OFFSET $SG4294967160
  001ac	68 00 00 00 00	 push	 OFFSET $SG4294967159
  001b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  001b7	83 c4 08	 add	 esp, 8
  001ba	a3 00 00 00 00	 mov	 DWORD PTR _hitsOut, eax
$LN28@RunMultiQI:

; 51   : 	}
; 52   : 	experimsOut = fopen("experimsOut.txt", "w");

  001bf	68 00 00 00 00	 push	 OFFSET $SG4294967158
  001c4	68 00 00 00 00	 push	 OFFSET $SG4294967157
  001c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  001cf	83 c4 08	 add	 esp, 8
  001d2	a3 00 00 00 00	 mov	 DWORD PTR _experimsOut, eax

; 53   : 	fprintf(experimsOut, "Gen;\t");

  001d7	68 00 00 00 00	 push	 OFFSET $SG4294967156
  001dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _experimsOut
  001e2	52		 push	 edx
  001e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  001e9	83 c4 08	 add	 esp, 8

; 54   : 	if (validatingData)

  001ec	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _validatingData, 0
  001f3	74 14		 je	 SHORT $LN27@RunMultiQI

; 55   : 	{
; 56   : 		fprintf(experimsOut, "BestValidIndiv;\t");

  001f5	68 00 00 00 00	 push	 OFFSET $SG4294967155
  001fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _experimsOut
  001ff	50		 push	 eax
  00200	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00206	83 c4 08	 add	 esp, 8
$LN27@RunMultiQI:

; 57   : 	}
; 58   : 	for (i = 0; i < popSize; i++)

  00209	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00210	eb 09		 jmp	 SHORT $LN26@RunMultiQI
$LN25@RunMultiQI:
  00212	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  00215	83 c1 01	 add	 ecx, 1
  00218	89 4d d4	 mov	 DWORD PTR _i$[ebp], ecx
$LN26@RunMultiQI:
  0021b	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  0021e	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _popSize
  00224	73 16		 jae	 SHORT $LN24@RunMultiQI

; 59   : 	{
; 60   : 		fprintf(experimsOut, "Len Train Valid;\t");

  00226	68 00 00 00 00	 push	 OFFSET $SG4294967154
  0022b	a1 00 00 00 00	 mov	 eax, DWORD PTR _experimsOut
  00230	50		 push	 eax
  00231	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00237	83 c4 08	 add	 esp, 8

; 61   : 	}

  0023a	eb d6		 jmp	 SHORT $LN25@RunMultiQI
$LN24@RunMultiQI:

; 62   : 	fprintf(experimsOut, "\n");

  0023c	68 00 00 00 00	 push	 OFFSET $SG4294967153
  00241	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _experimsOut
  00247	51		 push	 ecx
  00248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0024e	83 c4 08	 add	 esp, 8

; 63   : 
; 64   : 	EvalIndivFunc = classifProb ? EvalIndivHitRate : EvalIndiv;

  00251	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _classifProb
  00258	85 d2		 test	 edx, edx
  0025a	74 09		 je	 SHORT $LN34@RunMultiQI
  0025c	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv169[ebp], OFFSET _EvalIndivHitRate
  00263	eb 07		 jmp	 SHORT $LN35@RunMultiQI
$LN34@RunMultiQI:
  00265	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv169[ebp], OFFSET _EvalIndiv
$LN35@RunMultiQI:
  0026c	8b 45 cc	 mov	 eax, DWORD PTR tv169[ebp]
  0026f	a3 00 00 00 00	 mov	 DWORD PTR _EvalIndivFunc, eax

; 65   : 
; 66   : 	if (effObserving) //Disabled!!!

  00274	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _effObserving
  0027b	85 c9		 test	 ecx, ecx
  0027d	74 37		 je	 SHORT $LN23@RunMultiQI

; 67   : 	{
; 68   : 		//ObserveQIndivFunc = ObserveQIndivEff;
; 69   : 		ObserveQIndivFunc = ObserveQIndiv;

  0027f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ObserveQIndivFunc, OFFSET _ObserveQIndiv

; 70   : 		for (i = 0; i < qIndivLen; i++)

  00289	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00290	eb 09		 jmp	 SHORT $LN22@RunMultiQI
$LN21@RunMultiQI:
  00292	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  00295	83 c2 01	 add	 edx, 1
  00298	89 55 d4	 mov	 DWORD PTR _i$[ebp], edx
$LN22@RunMultiQI:
  0029b	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0029e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _qIndivLen
  002a4	73 0e		 jae	 SHORT $LN20@RunMultiQI

; 71   : 		{
; 72   : 			extrons[i] = 1;

  002a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _extrons
  002ac	03 4d d4	 add	 ecx, DWORD PTR _i$[ebp]
  002af	c6 01 01	 mov	 BYTE PTR [ecx], 1

; 73   : 		}

  002b2	eb de		 jmp	 SHORT $LN21@RunMultiQI
$LN20@RunMultiQI:

; 74   : 	}
; 75   : 	else

  002b4	eb 35		 jmp	 SHORT $LN16@RunMultiQI
$LN23@RunMultiQI:

; 76   : 	{
; 77   : 		ObserveQIndivFunc = ObserveQIndiv;

  002b6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ObserveQIndivFunc, OFFSET _ObserveQIndiv

; 78   : 		for (i = 0; i < qIndivLen; i++)

  002c0	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  002c7	eb 09		 jmp	 SHORT $LN18@RunMultiQI
$LN17@RunMultiQI:
  002c9	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  002cc	83 c2 01	 add	 edx, 1
  002cf	89 55 d4	 mov	 DWORD PTR _i$[ebp], edx
$LN18@RunMultiQI:
  002d2	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  002d5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _qIndivLen
  002db	73 0e		 jae	 SHORT $LN16@RunMultiQI

; 79   : 		{
; 80   : 			extrons[i] = 1;

  002dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _extrons
  002e3	03 4d d4	 add	 ecx, DWORD PTR _i$[ebp]
  002e6	c6 01 01	 mov	 BYTE PTR [ecx], 1

; 81   : 		}

  002e9	eb de		 jmp	 SHORT $LN17@RunMultiQI
$LN16@RunMultiQI:

; 82   : 	}
; 83   : 
; 84   : 	demes = NULL;

  002eb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _demes, 0

; 85   : 	// Loop to run all the experiments
; 86   : 	for (i = 0; i < nExperiments; i++)

  002f5	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  002fc	eb 09		 jmp	 SHORT $LN15@RunMultiQI
$LN14@RunMultiQI:
  002fe	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  00301	83 c2 01	 add	 edx, 1
  00304	89 55 d4	 mov	 DWORD PTR _i$[ebp], edx
$LN15@RunMultiQI:
  00307	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0030a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nExperiments
  00310	73 2e		 jae	 SHORT $LN13@RunMultiQI

; 87   : 	{
; 88   : 		printf("Experiment %d:\n", i);

  00312	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  00315	51		 push	 ecx
  00316	68 00 00 00 00	 push	 OFFSET $SG4294967152
  0031b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00321	83 c4 08	 add	 esp, 8

; 89   : 		RunExperiment(i);

  00324	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  00327	52		 push	 edx
  00328	e8 00 00 00 00	 call	 _RunExperiment
  0032d	83 c4 04	 add	 esp, 4

; 90   : 		printf("\n\n");

  00330	68 00 00 00 00	 push	 OFFSET $SG4294967151
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0033b	83 c4 04	 add	 esp, 4

; 91   : 	}

  0033e	eb be		 jmp	 SHORT $LN14@RunMultiQI
$LN13@RunMultiQI:

; 92   : 
; 93   : 	if (!validatingData)

  00340	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _validatingData, 0
  00347	75 0f		 jne	 SHORT $LN12@RunMultiQI

; 94   : 	{
; 95   : 		fclose(hitsOut);

  00349	a1 00 00 00 00	 mov	 eax, DWORD PTR _hitsOut
  0034e	50		 push	 eax
  0034f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00355	83 c4 04	 add	 esp, 4
$LN12@RunMultiQI:

; 96   : 	}
; 97   : 	fprintf(experimsOut, "\n#Evaluations = %d\n", nEvaluations);

  00358	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nEvaluations
  0035e	51		 push	 ecx
  0035f	68 00 00 00 00	 push	 OFFSET $SG4294967150
  00364	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _experimsOut
  0036a	52		 push	 edx
  0036b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00371	83 c4 0c	 add	 esp, 12			; 0000000cH

; 98   : 	if (testingData)

  00374	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _testingData, 0
  0037b	0f 84 50 01 00
	00		 je	 $LN8@RunMultiQI

; 99   : 	{
; 100  : 		fprintf(experimsOut, "Best evolved individual:\n");

  00381	68 00 00 00 00	 push	 OFFSET $SG4294967149
  00386	a1 00 00 00 00	 mov	 eax, DWORD PTR _experimsOut
  0038b	50		 push	 eax
  0038c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00392	83 c4 08	 add	 esp, 8

; 101  : 		fprintf(experimsOut, "  Length = %d\n", bestTkIndiv.length);

  00395	0f b6 0d 20 00
	00 00		 movzx	 ecx, BYTE PTR _bestTkIndiv+32
  0039c	51		 push	 ecx
  0039d	68 00 00 00 00	 push	 OFFSET $SG4294967148
  003a2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _experimsOut
  003a8	52		 push	 edx
  003a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  003af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 102  : 		Assemble(&bestTkIndiv);

  003b2	68 00 00 00 00	 push	 OFFSET _bestTkIndiv
  003b7	e8 00 00 00 00	 call	 _Assemble
  003bc	83 c4 04	 add	 esp, 4

; 103  :         fprintf(experimsOut, "  Training error   = %g\n", EvalIndivFunc(trainingData, nSamplesTrain, &bestTkIndiv)); //bestTkIndiv.fitness);  //

  003bf	68 00 00 00 00	 push	 OFFSET _bestTkIndiv
  003c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _nSamplesTrain
  003c9	50		 push	 eax
  003ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _trainingData
  003d0	51		 push	 ecx
  003d1	ff 15 00 00 00
	00		 call	 DWORD PTR _EvalIndivFunc
  003d7	83 c4 04	 add	 esp, 4
  003da	dd 1c 24	 fstp	 QWORD PTR [esp]
  003dd	68 00 00 00 00	 push	 OFFSET $SG4294967147
  003e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _experimsOut
  003e8	52		 push	 edx
  003e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  003ef	83 c4 10	 add	 esp, 16			; 00000010H

; 104  : 		fprintf(experimsOut, "  Validating error = %g\n", EvalIndivFunc(validatingData, nSamplesValid, &bestTkIndiv)); //bestTkIndiv.validFitness);  //

  003f2	68 00 00 00 00	 push	 OFFSET _bestTkIndiv
  003f7	a1 00 00 00 00	 mov	 eax, DWORD PTR _nSamplesValid
  003fc	50		 push	 eax
  003fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validatingData
  00403	51		 push	 ecx
  00404	ff 15 00 00 00
	00		 call	 DWORD PTR _EvalIndivFunc
  0040a	83 c4 04	 add	 esp, 4
  0040d	dd 1c 24	 fstp	 QWORD PTR [esp]
  00410	68 00 00 00 00	 push	 OFFSET $SG4294967146
  00415	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _experimsOut
  0041b	52		 push	 edx
  0041c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00422	83 c4 10	 add	 esp, 16			; 00000010H

; 105  :         fprintf(experimsOut, "  Testing error    = %g\n", EvalIndivFunc(testingData, nSamplesTest, &bestTkIndiv));

  00425	68 00 00 00 00	 push	 OFFSET _bestTkIndiv
  0042a	a1 00 00 00 00	 mov	 eax, DWORD PTR _nSamplesTest
  0042f	50		 push	 eax
  00430	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _testingData
  00436	51		 push	 ecx
  00437	ff 15 00 00 00
	00		 call	 DWORD PTR _EvalIndivFunc
  0043d	83 c4 04	 add	 esp, 4
  00440	dd 1c 24	 fstp	 QWORD PTR [esp]
  00443	68 00 00 00 00	 push	 OFFSET $SG4294967145
  00448	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _experimsOut
  0044e	52		 push	 edx
  0044f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00455	83 c4 10	 add	 esp, 16			; 00000010H

; 106  : 		fprintf(experimsOut, "  Genotype: ");

  00458	68 00 00 00 00	 push	 OFFSET $SG4294967144
  0045d	a1 00 00 00 00	 mov	 eax, DWORD PTR _experimsOut
  00462	50		 push	 eax
  00463	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00469	83 c4 08	 add	 esp, 8

; 107  : 		for (i = 0; i < qIndivLen; i++)

  0046c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00473	eb 09		 jmp	 SHORT $LN10@RunMultiQI
$LN9@RunMultiQI:
  00475	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  00478	83 c1 01	 add	 ecx, 1
  0047b	89 4d d4	 mov	 DWORD PTR _i$[ebp], ecx
$LN10@RunMultiQI:
  0047e	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  00481	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _qIndivLen
  00487	73 48		 jae	 SHORT $LN8@RunMultiQI

; 108  : 		{
; 109  : 			fprintf(experimsOut, "%x,", bestTkIndiv.genome[2*i]);

  00489	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0048c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bestTkIndiv
  00492	0f b6 14 41	 movzx	 edx, BYTE PTR [ecx+eax*2]
  00496	52		 push	 edx
  00497	68 00 00 00 00	 push	 OFFSET $SG4294967143
  0049c	a1 00 00 00 00	 mov	 eax, DWORD PTR _experimsOut
  004a1	50		 push	 eax
  004a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  004a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 110  : 			fprintf(experimsOut, "%x ", bestTkIndiv.genome[2*i+1]);

  004ab	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  004ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _bestTkIndiv
  004b4	0f b6 44 4a 01	 movzx	 eax, BYTE PTR [edx+ecx*2+1]
  004b9	50		 push	 eax
  004ba	68 00 00 00 00	 push	 OFFSET $SG4294967142
  004bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _experimsOut
  004c5	51		 push	 ecx
  004c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  004cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 111  : 		}

  004cf	eb a4		 jmp	 SHORT $LN9@RunMultiQI
$LN8@RunMultiQI:

; 112  : 	}
; 113  : 	fclose(experimsOut);

  004d1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _experimsOut
  004d7	52		 push	 edx
  004d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  004de	83 c4 04	 add	 esp, 4

; 114  : 
; 115  : 	averageOut = fopen("averageOut.txt", "w");

  004e1	68 00 00 00 00	 push	 OFFSET $SG4294967141
  004e6	68 00 00 00 00	 push	 OFFSET $SG4294967140
  004eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  004f1	83 c4 08	 add	 esp, 8
  004f4	a3 00 00 00 00	 mov	 DWORD PTR _averageOut, eax

; 116  : 	for (i = 0; i < nGenerations / writeFreq; i++)

  004f9	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00500	eb 09		 jmp	 SHORT $LN7@RunMultiQI
$LN6@RunMultiQI:
  00502	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00505	83 c0 01	 add	 eax, 1
  00508	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN7@RunMultiQI:
  0050b	a1 00 00 00 00	 mov	 eax, DWORD PTR _nGenerations
  00510	33 d2		 xor	 edx, edx
  00512	f7 35 00 00 00
	00		 div	 DWORD PTR _writeFreq
  00518	39 45 d4	 cmp	 DWORD PTR _i$[ebp], eax
  0051b	0f 83 59 01 00
	00		 jae	 $LN5@RunMultiQI

; 117  : 	{
; 118  : 		accumFit[i] /= nExperiments;

  00521	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nExperiments
  00527	89 4d c8	 mov	 DWORD PTR tv506[ebp], ecx
  0052a	f2 0f 2a 45 c8	 cvtsi2sd xmm0, DWORD PTR tv506[ebp]
  0052f	8b 55 c8	 mov	 edx, DWORD PTR tv506[ebp]
  00532	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  00535	f2 0f 58 04 d5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
  0053e	f2 0f 11 45 c0	 movsd	 QWORD PTR tv510[ebp], xmm0
  00543	f2 0f 5a 45 c0	 cvtsd2ss xmm0, QWORD PTR tv510[ebp]
  00548	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0054b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _accumFit
  00551	f3 0f 10 0c 81	 movss	 xmm1, DWORD PTR [ecx+eax*4]
  00556	f3 0f 5e c8	 divss	 xmm1, xmm0
  0055a	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  0055d	a1 00 00 00 00	 mov	 eax, DWORD PTR _accumFit
  00562	f3 0f 11 0c 90	 movss	 DWORD PTR [eax+edx*4], xmm1

; 119  : 		accumLen[i] /= nExperiments;

  00567	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  0056a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumLen
  00570	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00573	33 d2		 xor	 edx, edx
  00575	f7 35 00 00 00
	00		 div	 DWORD PTR _nExperiments
  0057b	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  0057e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumLen
  00584	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 120  : 		if (validatingData)

  00587	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _validatingData, 0
  0058e	0f 84 9f 00 00
	00		 je	 $LN4@RunMultiQI

; 121  : 		{
; 122  : 			accumValFit[i] /= nExperiments;

  00594	a1 00 00 00 00	 mov	 eax, DWORD PTR _nExperiments
  00599	89 45 d0	 mov	 DWORD PTR tv527[ebp], eax
  0059c	f2 0f 2a 45 d0	 cvtsi2sd xmm0, DWORD PTR tv527[ebp]
  005a1	8b 4d d0	 mov	 ecx, DWORD PTR tv527[ebp]
  005a4	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  005a7	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  005b0	f2 0f 11 45 b8	 movsd	 QWORD PTR tv531[ebp], xmm0
  005b5	f2 0f 5a 45 b8	 cvtsd2ss xmm0, QWORD PTR tv531[ebp]
  005ba	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  005bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _accumValFit
  005c2	f3 0f 10 0c 90	 movss	 xmm1, DWORD PTR [eax+edx*4]
  005c7	f3 0f 5e c8	 divss	 xmm1, xmm0
  005cb	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  005ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumValFit
  005d4	f3 0f 11 0c 8a	 movss	 DWORD PTR [edx+ecx*4], xmm1

; 123  : 			fprintf(averageOut, "%d %g %g %d\n", i * writeFreq, accumFit[i], accumValFit[i], accumLen[i]); //!!!

  005d9	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  005dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _accumLen
  005e2	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  005e5	52		 push	 edx
  005e6	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  005e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _accumValFit
  005ef	f3 0f 5a 04 81	 cvtss2sd xmm0, DWORD PTR [ecx+eax*4]
  005f4	83 ec 08	 sub	 esp, 8
  005f7	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  005fc	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  005ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _accumFit
  00604	f3 0f 5a 04 90	 cvtss2sd xmm0, DWORD PTR [eax+edx*4]
  00609	83 ec 08	 sub	 esp, 8
  0060c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00611	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  00614	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR _writeFreq
  0061b	51		 push	 ecx
  0061c	68 00 00 00 00	 push	 OFFSET $SG4294967139
  00621	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _averageOut
  00627	52		 push	 edx
  00628	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0062e	83 c4 20	 add	 esp, 32			; 00000020H

; 124  : 		}
; 125  : 		else

  00631	eb 42		 jmp	 SHORT $LN3@RunMultiQI
$LN4@RunMultiQI:

; 126  : 		{
; 127  : 			fprintf(averageOut, "%d %g %d\n", i * writeFreq, accumFit[i], accumLen[i]);

  00633	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00636	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _accumLen
  0063c	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0063f	52		 push	 edx
  00640	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00643	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _accumFit
  00649	f3 0f 5a 04 81	 cvtss2sd xmm0, DWORD PTR [ecx+eax*4]
  0064e	83 ec 08	 sub	 esp, 8
  00651	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00656	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  00659	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR _writeFreq
  00660	52		 push	 edx
  00661	68 00 00 00 00	 push	 OFFSET $SG4294967138
  00666	a1 00 00 00 00	 mov	 eax, DWORD PTR _averageOut
  0066b	50		 push	 eax
  0066c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00672	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@RunMultiQI:

; 128  : 		}
; 129  : 	}

  00675	e9 88 fe ff ff	 jmp	 $LN6@RunMultiQI
$LN5@RunMultiQI:

; 130  : 	if (validatingData)

  0067a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _validatingData, 0
  00681	74 5d		 je	 SHORT $LN2@RunMultiQI

; 131  : 	{
; 132  : 		fprintf(averageOut, "%d %g %g %d\n", i * writeFreq, accumFit[i-1], accumValFit[i-1], accumLen[i-1]);

  00683	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  00686	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumLen
  0068c	8b 44 8a fc	 mov	 eax, DWORD PTR [edx+ecx*4-4]
  00690	50		 push	 eax
  00691	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  00694	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumValFit
  0069a	f3 0f 5a 44 8a
	fc		 cvtss2sd xmm0, DWORD PTR [edx+ecx*4-4]
  006a0	83 ec 08	 sub	 esp, 8
  006a3	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  006a8	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  006ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _accumFit
  006b1	f3 0f 5a 44 81
	fc		 cvtss2sd xmm0, DWORD PTR [ecx+eax*4-4]
  006b7	83 ec 08	 sub	 esp, 8
  006ba	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  006bf	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  006c2	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR _writeFreq
  006c9	52		 push	 edx
  006ca	68 00 00 00 00	 push	 OFFSET $SG4294967137
  006cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _averageOut
  006d4	50		 push	 eax
  006d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  006db	83 c4 20	 add	 esp, 32			; 00000020H

; 133  : 	}
; 134  : 	else

  006de	eb 45		 jmp	 SHORT $LN1@RunMultiQI
$LN2@RunMultiQI:

; 135  : 	{
; 136  : 		fprintf(averageOut, "%d %g %d\n", i * writeFreq, accumFit[i-1], accumLen[i-1]);

  006e0	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  006e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumLen
  006e9	8b 44 8a fc	 mov	 eax, DWORD PTR [edx+ecx*4-4]
  006ed	50		 push	 eax
  006ee	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  006f1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumFit
  006f7	f3 0f 5a 44 8a
	fc		 cvtss2sd xmm0, DWORD PTR [edx+ecx*4-4]
  006fd	83 ec 08	 sub	 esp, 8
  00700	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00705	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00708	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _writeFreq
  0070f	50		 push	 eax
  00710	68 00 00 00 00	 push	 OFFSET $SG4294967136
  00715	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _averageOut
  0071b	51		 push	 ecx
  0071c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00722	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@RunMultiQI:

; 137  : 	}
; 138  : 	fclose(averageOut);

  00725	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _averageOut
  0072b	52		 push	 edx
  0072c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00732	83 c4 04	 add	 esp, 4

; 139  : 
; 140  : 	Assemble(&bestTkIndiv);

  00735	68 00 00 00 00	 push	 OFFSET _bestTkIndiv
  0073a	e8 00 00 00 00	 call	 _Assemble
  0073f	83 c4 04	 add	 esp, 4

; 141  : 	WriteBestProgOuts(fileTrnName, trainingData, nSamplesTrain);

  00742	a1 00 00 00 00	 mov	 eax, DWORD PTR _nSamplesTrain
  00747	50		 push	 eax
  00748	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _trainingData
  0074e	51		 push	 ecx
  0074f	8d 55 e4	 lea	 edx, DWORD PTR _fileTrnName$[ebp]
  00752	52		 push	 edx
  00753	e8 00 00 00 00	 call	 _WriteBestProgOuts
  00758	83 c4 0c	 add	 esp, 12			; 0000000cH

; 142  : 	WriteBestProgOuts(fileVldName, validatingData, nSamplesValid);

  0075b	a1 00 00 00 00	 mov	 eax, DWORD PTR _nSamplesValid
  00760	50		 push	 eax
  00761	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validatingData
  00767	51		 push	 ecx
  00768	8d 55 d8	 lea	 edx, DWORD PTR _fileVldName$[ebp]
  0076b	52		 push	 edx
  0076c	e8 00 00 00 00	 call	 _WriteBestProgOuts
  00771	83 c4 0c	 add	 esp, 12			; 0000000cH

; 143  : 	WriteBestProgOuts(fileTstName, testingData, nSamplesTest);

  00774	a1 00 00 00 00	 mov	 eax, DWORD PTR _nSamplesTest
  00779	50		 push	 eax
  0077a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _testingData
  00780	51		 push	 ecx
  00781	8d 55 f0	 lea	 edx, DWORD PTR _fileTstName$[ebp]
  00784	52		 push	 edx
  00785	e8 00 00 00 00	 call	 _WriteBestProgOuts
  0078a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  : 
; 145  :     return bestTkIndiv.fitness;

  0078d	dd 05 08 00 00
	00		 fld	 QWORD PTR _bestTkIndiv+8

; 146  : }

  00793	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00796	33 cd		 xor	 ecx, ebp
  00798	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0079d	8b e5		 mov	 esp, ebp
  0079f	5d		 pop	 ebp
  007a0	c3		 ret	 0
_RunMultiQILGP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\evolution.c
_TEXT	SEGMENT
_expBestValFit$ = -32					; size = 8
_expBestFit$ = -24					; size = 8
_fpExp$ = -16						; size = 4
_wrFreqCount$ = -12					; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_expNo$ = 8						; size = 4
_RunExperiment PROC

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 200  : 	unsigned int i, j, wrFreqCount;
; 201  : 	double expBestFit = HUGE_VAL;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___HUGE
  0000b	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  0000f	f2 0f 11 45 e8	 movsd	 QWORD PTR _expBestFit$[ebp], xmm0

; 202  : 	double expBestValFit = HUGE_VAL;

  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___HUGE
  0001a	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  0001e	f2 0f 11 45 e0	 movsd	 QWORD PTR _expBestValFit$[ebp], xmm0

; 203  :     FILE *fpExp;
; 204  : 	
; 205  : 	//InitQPop();
; 206  : 	//InitTkPop();
; 207  : 	InitDemes();

  00023	e8 00 00 00 00	 call	 _InitDemes

; 208  : 
; 209  : 	wrFreqCount = 0;

  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _wrFreqCount$[ebp], 0

; 210  : 	gwi = 1;

  0002f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _gwi, 1

; 211  :     nEvalsExp = 0;

  00039	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nEvalsExp, 0

; 212  : 	i = 0;

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 213  : 
; 214  :     bestExpTkIndiv.fitness = HUGE_VAL;

  0004a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp___HUGE
  00050	f2 0f 10 02	 movsd	 xmm0, QWORD PTR [edx]
  00054	f2 0f 11 05 08
	00 00 00	 movsd	 QWORD PTR _bestExpTkIndiv+8, xmm0

; 215  :     bestExpTkIndiv.validFitness = HUGE_VAL;

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___HUGE
  00061	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00065	f2 0f 11 05 10
	00 00 00	 movsd	 QWORD PTR _bestExpTkIndiv+16, xmm0

; 216  :     bestExpTkIndiv.error = HUGE_VAL;

  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___HUGE
  00073	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  00077	f2 0f 11 05 18
	00 00 00	 movsd	 QWORD PTR _bestExpTkIndiv+24, xmm0

; 217  : 	
; 218  : 	//RunGeneration(i, &expBestFit);
; 219  : 	RunGenerationDemes(i, &expBestFit);

  0007f	8d 55 e8	 lea	 edx, DWORD PTR _expBestFit$[ebp]
  00082	52		 push	 edx
  00083	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _RunGenerationDemes
  0008c	83 c4 08	 add	 esp, 8

; 220  : 	accumFit[0] += tkPop[0].fitness; //expBestFit;

  0008f	b9 04 00 00 00	 mov	 ecx, 4
  00094	6b d1 00	 imul	 edx, ecx, 0
  00097	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  0009c	6b c8 00	 imul	 ecx, eax, 0
  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR _accumFit
  000a4	f3 0f 5a 04 10	 cvtss2sd xmm0, DWORD PTR [eax+edx]
  000a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tkPop
  000af	f2 0f 58 44 0a
	08		 addsd	 xmm0, QWORD PTR [edx+ecx+8]
  000b5	b8 04 00 00 00	 mov	 eax, 4
  000ba	6b c8 00	 imul	 ecx, eax, 0
  000bd	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  000c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumFit
  000c7	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 221  : 	accumLen[0] += tkPop[0].length;

  000cc	b8 04 00 00 00	 mov	 eax, 4
  000d1	6b c8 00	 imul	 ecx, eax, 0
  000d4	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  000d9	6b c2 00	 imul	 eax, edx, 0
  000dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tkPop
  000e2	0f b6 44 02 20	 movzx	 eax, BYTE PTR [edx+eax+32]
  000e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumLen
  000ed	03 04 0a	 add	 eax, DWORD PTR [edx+ecx]
  000f0	b9 04 00 00 00	 mov	 ecx, 4
  000f5	6b d1 00	 imul	 edx, ecx, 0
  000f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _accumLen
  000fe	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 222  :     accumValFit[0] += bestTkIndiv.validFitness;

  00101	ba 04 00 00 00	 mov	 edx, 4
  00106	6b c2 00	 imul	 eax, edx, 0
  00109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _accumValFit
  0010f	f3 0f 5a 04 01	 cvtss2sd xmm0, DWORD PTR [ecx+eax]
  00114	f2 0f 58 05 10
	00 00 00	 addsd	 xmm0, QWORD PTR _bestTkIndiv+16
  0011c	ba 04 00 00 00	 mov	 edx, 4
  00121	6b c2 00	 imul	 eax, edx, 0
  00124	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00128	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _accumValFit
  0012e	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 223  : 
; 224  : 	for (i = 1, wrFreqCount = 1; i <= nGenerations; i++, wrFreqCount++) //!!!

  00133	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0013a	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _wrFreqCount$[ebp], 1
  00141	eb 12		 jmp	 SHORT $LN13@RunExperim
$LN12@RunExperim:
  00143	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00146	83 c2 01	 add	 edx, 1
  00149	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  0014c	8b 45 f4	 mov	 eax, DWORD PTR _wrFreqCount$[ebp]
  0014f	83 c0 01	 add	 eax, 1
  00152	89 45 f4	 mov	 DWORD PTR _wrFreqCount$[ebp], eax
$LN13@RunExperim:
  00155	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00158	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _nGenerations
  0015e	0f 87 ad 01 00
	00		 ja	 $LN11@RunExperim

; 225  : 	{
; 226  : 		//RunGeneration(i, &expBestFit);
; 227  : 		RunGenerationDemes(i, &expBestFit);

  00164	8d 55 e8	 lea	 edx, DWORD PTR _expBestFit$[ebp]
  00167	52		 push	 edx
  00168	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 _RunGenerationDemes
  00171	83 c4 08	 add	 esp, 8

; 228  : 		if (wrFreqCount == writeFreq)

  00174	8b 4d f4	 mov	 ecx, DWORD PTR _wrFreqCount$[ebp]
  00177	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _writeFreq
  0017d	0f 85 89 01 00
	00		 jne	 $LN10@RunExperim

; 229  : 		{
; 230  : 			accumFit[i/writeFreq] += bestExpTkIndiv.fitness;//tkPop[0].fitness;//expBestFit;

  00183	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00186	33 d2		 xor	 edx, edx
  00188	f7 35 00 00 00
	00		 div	 DWORD PTR _writeFreq
  0018e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumFit
  00194	f3 0f 5a 04 82	 cvtss2sd xmm0, DWORD PTR [edx+eax*4]
  00199	f2 0f 58 05 08
	00 00 00	 addsd	 xmm0, QWORD PTR _bestExpTkIndiv+8
  001a1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001a4	33 d2		 xor	 edx, edx
  001a6	f7 35 00 00 00
	00		 div	 DWORD PTR _writeFreq
  001ac	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _accumFit
  001b6	f3 0f 11 04 81	 movss	 DWORD PTR [ecx+eax*4], xmm0

; 231  : 			accumLen[i/writeFreq] += bestExpTkIndiv.length;//tkPop[0].length;

  001bb	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001be	33 d2		 xor	 edx, edx
  001c0	f7 35 00 00 00
	00		 div	 DWORD PTR _writeFreq
  001c6	0f b6 0d 20 00
	00 00		 movzx	 ecx, BYTE PTR _bestExpTkIndiv+32
  001cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumLen
  001d3	03 0c 82	 add	 ecx, DWORD PTR [edx+eax*4]
  001d6	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001d9	33 d2		 xor	 edx, edx
  001db	f7 35 00 00 00
	00		 div	 DWORD PTR _writeFreq
  001e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumLen
  001e7	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx

; 232  : 			fprintf(experimsOut, "%d;\t", i);

  001ea	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001ed	50		 push	 eax
  001ee	68 00 00 00 00	 push	 OFFSET $SG4294967135
  001f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _experimsOut
  001f9	51		 push	 ecx
  001fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00200	83 c4 0c	 add	 esp, 12			; 0000000cH

; 233  : 			if (validatingData)

  00203	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _validatingData, 0
  0020a	74 74		 je	 SHORT $LN9@RunExperim

; 234  : 			{
; 235  :                 accumValFit[i/writeFreq] += bestExpTkIndiv.validFitness;

  0020c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0020f	33 d2		 xor	 edx, edx
  00211	f7 35 00 00 00
	00		 div	 DWORD PTR _writeFreq
  00217	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _accumValFit
  0021d	f3 0f 5a 04 82	 cvtss2sd xmm0, DWORD PTR [edx+eax*4]
  00222	f2 0f 58 05 10
	00 00 00	 addsd	 xmm0, QWORD PTR _bestExpTkIndiv+16
  0022a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0022d	33 d2		 xor	 edx, edx
  0022f	f7 35 00 00 00
	00		 div	 DWORD PTR _writeFreq
  00235	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00239	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _accumValFit
  0023f	f3 0f 11 04 81	 movss	 DWORD PTR [ecx+eax*4], xmm0

; 236  : 				fprintf(experimsOut, "%d %g %g;\t", bestExpTkIndiv.length, bestExpTkIndiv.fitness, 
; 237  :                     bestExpTkIndiv.validFitness);

  00244	83 ec 08	 sub	 esp, 8
  00247	f2 0f 10 05 10
	00 00 00	 movsd	 xmm0, QWORD PTR _bestExpTkIndiv+16
  0024f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00254	83 ec 08	 sub	 esp, 8
  00257	f2 0f 10 05 08
	00 00 00	 movsd	 xmm0, QWORD PTR _bestExpTkIndiv+8
  0025f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00264	0f b6 15 20 00
	00 00		 movzx	 edx, BYTE PTR _bestExpTkIndiv+32
  0026b	52		 push	 edx
  0026c	68 00 00 00 00	 push	 OFFSET $SG4294967134
  00271	a1 00 00 00 00	 mov	 eax, DWORD PTR _experimsOut
  00276	50		 push	 eax
  00277	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0027d	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN9@RunExperim:

; 238  : 			}
; 239  :             // For no demes
; 240  : 			//for (j = 0; j < popSize; j++)
; 241  : 			//{
; 242  : 			//	fprintf(experimsOut, "%d %g %g;\t", tkPop[j].length, tkPop[j].fitness, tkPop[j].validFitness);
; 243  : 			//}
; 244  : 			
; 245  :             // For demes
; 246  :             for (j = 0; j < nDemes; j++)

  00280	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00287	eb 09		 jmp	 SHORT $LN8@RunExperim
$LN7@RunExperim:
  00289	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  0028c	83 c1 01	 add	 ecx, 1
  0028f	89 4d f8	 mov	 DWORD PTR _j$[ebp], ecx
$LN8@RunExperim:
  00292	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  00295	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _nDemes
  0029b	73 56		 jae	 SHORT $LN6@RunExperim

; 247  : 			{
; 248  :                 fprintf(experimsOut, "%d %g %g;\t", demes[j].bestTkIndiv.length, demes[j].bestTkIndiv.fitness, 
; 249  :                         demes[j].bestTkIndiv.validFitness);

  0029d	6b 45 f8 60	 imul	 eax, DWORD PTR _j$[ebp], 96
  002a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  002a7	83 ec 08	 sub	 esp, 8
  002aa	f2 0f 10 44 01
	18		 movsd	 xmm0, QWORD PTR [ecx+eax+24]
  002b0	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002b5	6b 55 f8 60	 imul	 edx, DWORD PTR _j$[ebp], 96
  002b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  002be	83 ec 08	 sub	 esp, 8
  002c1	f2 0f 10 44 10
	10		 movsd	 xmm0, QWORD PTR [eax+edx+16]
  002c7	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002cc	6b 4d f8 60	 imul	 ecx, DWORD PTR _j$[ebp], 96
  002d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  002d6	0f b6 44 0a 28	 movzx	 eax, BYTE PTR [edx+ecx+40]
  002db	50		 push	 eax
  002dc	68 00 00 00 00	 push	 OFFSET $SG4294967133
  002e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _experimsOut
  002e7	51		 push	 ecx
  002e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  002ee	83 c4 1c	 add	 esp, 28			; 0000001cH

; 250  : 			}

  002f1	eb 96		 jmp	 SHORT $LN7@RunExperim
$LN6@RunExperim:

; 251  :             
; 252  :             fputc('\n', experimsOut);

  002f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _experimsOut
  002f9	52		 push	 edx
  002fa	6a 0a		 push	 10			; 0000000aH
  002fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputc
  00302	83 c4 08	 add	 esp, 8

; 253  : 			wrFreqCount = 0;

  00305	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _wrFreqCount$[ebp], 0
$LN10@RunExperim:

; 254  : 		}
; 255  : 	}

  0030c	e9 32 fe ff ff	 jmp	 $LN12@RunExperim
$LN11@RunExperim:

; 256  : 	if (expBestFit < bestFit)

  00311	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _bestFit
  00319	66 0f 2f 45 e8	 comisd	 xmm0, QWORD PTR _expBestFit$[ebp]
  0031e	76 0d		 jbe	 SHORT $LN5@RunExperim

; 257  : 	{
; 258  : 		bestFit = expBestFit;

  00320	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _expBestFit$[ebp]
  00325	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _bestFit, xmm0
$LN5@RunExperim:

; 259  : 	}
; 260  : 
; 261  : 	if (validatingData)

  0032d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _validatingData, 0
  00334	74 4a		 je	 SHORT $LN4@RunExperim

; 262  : 	{
; 263  : 		printf("\nPrograms evaluated=%d", nEvalsExp);

  00336	a1 00 00 00 00	 mov	 eax, DWORD PTR _nEvalsExp
  0033b	50		 push	 eax
  0033c	68 00 00 00 00	 push	 OFFSET $SG4294967132
  00341	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00347	83 c4 08	 add	 esp, 8

; 264  :         printf("\nBest Program: T=%g; V=%g; L=%d\n\n", bestExpTkIndiv.fitness, 
; 265  :             bestExpTkIndiv.validFitness, bestExpTkIndiv.length);

  0034a	0f b6 0d 20 00
	00 00		 movzx	 ecx, BYTE PTR _bestExpTkIndiv+32
  00351	51		 push	 ecx
  00352	83 ec 08	 sub	 esp, 8
  00355	f2 0f 10 05 10
	00 00 00	 movsd	 xmm0, QWORD PTR _bestExpTkIndiv+16
  0035d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00362	83 ec 08	 sub	 esp, 8
  00365	f2 0f 10 05 08
	00 00 00	 movsd	 xmm0, QWORD PTR _bestExpTkIndiv+8
  0036d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00372	68 00 00 00 00	 push	 OFFSET $SG4294967131
  00377	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0037d	83 c4 18	 add	 esp, 24			; 00000018H
$LN4@RunExperim:

; 266  : 	}
; 267  : 	
; 268  : 	Assemble(&bestExpTkIndiv); // Just to calculate test error

  00380	68 00 00 00 00	 push	 OFFSET _bestExpTkIndiv
  00385	e8 00 00 00 00	 call	 _Assemble
  0038a	83 c4 04	 add	 esp, 4

; 269  : 
; 270  : 	fprintf(experimsOut, "Best: Len=%d; Trn=%g; Val=%g; Tst=%g;\n", 
; 271  : 		    bestExpTkIndiv.length, 
; 272  : 			//bestExpTkIndiv.fitness, bestExpTkIndiv.validFitness,
; 273  : 			EvalIndivFunc(trainingData, nSamplesTrain, &bestExpTkIndiv), // Maybe useless
; 274  : 			EvalIndivFunc(validatingData, nSamplesValid, &bestExpTkIndiv), // Maybe useless
; 275  : 		    EvalIndivFunc(testingData, nSamplesTest, &bestExpTkIndiv));

  0038d	68 00 00 00 00	 push	 OFFSET _bestExpTkIndiv
  00392	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nSamplesTest
  00398	52		 push	 edx
  00399	a1 00 00 00 00	 mov	 eax, DWORD PTR _testingData
  0039e	50		 push	 eax
  0039f	ff 15 00 00 00
	00		 call	 DWORD PTR _EvalIndivFunc
  003a5	83 c4 04	 add	 esp, 4
  003a8	dd 1c 24	 fstp	 QWORD PTR [esp]
  003ab	68 00 00 00 00	 push	 OFFSET _bestExpTkIndiv
  003b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nSamplesValid
  003b6	51		 push	 ecx
  003b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _validatingData
  003bd	52		 push	 edx
  003be	ff 15 00 00 00
	00		 call	 DWORD PTR _EvalIndivFunc
  003c4	83 c4 04	 add	 esp, 4
  003c7	dd 1c 24	 fstp	 QWORD PTR [esp]
  003ca	68 00 00 00 00	 push	 OFFSET _bestExpTkIndiv
  003cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _nSamplesTrain
  003d4	50		 push	 eax
  003d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _trainingData
  003db	51		 push	 ecx
  003dc	ff 15 00 00 00
	00		 call	 DWORD PTR _EvalIndivFunc
  003e2	83 c4 04	 add	 esp, 4
  003e5	dd 1c 24	 fstp	 QWORD PTR [esp]
  003e8	0f b6 15 20 00
	00 00		 movzx	 edx, BYTE PTR _bestExpTkIndiv+32
  003ef	52		 push	 edx
  003f0	68 00 00 00 00	 push	 OFFSET $SG4294967130
  003f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _experimsOut
  003fa	50		 push	 eax
  003fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00401	83 c4 24	 add	 esp, 36			; 00000024H

; 276  : 	fprintf(experimsOut, "  Genotype: ");

  00404	68 00 00 00 00	 push	 OFFSET $SG4294967129
  00409	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _experimsOut
  0040f	51		 push	 ecx
  00410	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00416	83 c4 08	 add	 esp, 8

; 277  : 	for (i = 0; i < qIndivLen; i++)

  00419	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00420	eb 09		 jmp	 SHORT $LN3@RunExperim
$LN2@RunExperim:
  00422	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00425	83 c2 01	 add	 edx, 1
  00428	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN3@RunExperim:
  0042b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0042e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _qIndivLen
  00434	73 48		 jae	 SHORT $LN1@RunExperim

; 278  : 	{
; 279  : 		fprintf(experimsOut, "%x,", bestTkIndiv.genome[2*i]);

  00436	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00439	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _bestTkIndiv
  0043f	0f b6 04 4a	 movzx	 eax, BYTE PTR [edx+ecx*2]
  00443	50		 push	 eax
  00444	68 00 00 00 00	 push	 OFFSET $SG4294967128
  00449	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _experimsOut
  0044f	51		 push	 ecx
  00450	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00456	83 c4 0c	 add	 esp, 12			; 0000000cH

; 280  : 		fprintf(experimsOut, "%x ", bestTkIndiv.genome[2*i+1]);

  00459	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0045c	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestTkIndiv
  00461	0f b6 4c 50 01	 movzx	 ecx, BYTE PTR [eax+edx*2+1]
  00466	51		 push	 ecx
  00467	68 00 00 00 00	 push	 OFFSET $SG4294967127
  0046c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _experimsOut
  00472	52		 push	 edx
  00473	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00479	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  : 	}

  0047c	eb a4		 jmp	 SHORT $LN2@RunExperim
$LN1@RunExperim:

; 282  : 	fprintf(experimsOut, "\n\n");

  0047e	68 00 00 00 00	 push	 OFFSET $SG4294967126
  00483	a1 00 00 00 00	 mov	 eax, DWORD PTR _experimsOut
  00488	50		 push	 eax
  00489	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0048f	83 c4 08	 add	 esp, 8

; 283  : 
; 284  :     fpExp = NewExperimOutFile("trainOut", expNo);

  00492	8b 4d 08	 mov	 ecx, DWORD PTR _expNo$[ebp]
  00495	51		 push	 ecx
  00496	68 00 00 00 00	 push	 OFFSET $SG4294967125
  0049b	e8 00 00 00 00	 call	 _NewExperimOutFile
  004a0	83 c4 08	 add	 esp, 8
  004a3	89 45 f0	 mov	 DWORD PTR _fpExp$[ebp], eax

; 285  :     WriteProgOuts(fpExp, trainingData, nSamplesTrain);

  004a6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nSamplesTrain
  004ac	52		 push	 edx
  004ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _trainingData
  004b2	50		 push	 eax
  004b3	8b 4d f0	 mov	 ecx, DWORD PTR _fpExp$[ebp]
  004b6	51		 push	 ecx
  004b7	e8 00 00 00 00	 call	 _WriteProgOuts
  004bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 286  :     fpExp = NewExperimOutFile("validOut", expNo);

  004bf	8b 55 08	 mov	 edx, DWORD PTR _expNo$[ebp]
  004c2	52		 push	 edx
  004c3	68 00 00 00 00	 push	 OFFSET $SG4294967124
  004c8	e8 00 00 00 00	 call	 _NewExperimOutFile
  004cd	83 c4 08	 add	 esp, 8
  004d0	89 45 f0	 mov	 DWORD PTR _fpExp$[ebp], eax

; 287  :     WriteProgOuts(fpExp, validatingData, nSamplesValid);

  004d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _nSamplesValid
  004d8	50		 push	 eax
  004d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validatingData
  004df	51		 push	 ecx
  004e0	8b 55 f0	 mov	 edx, DWORD PTR _fpExp$[ebp]
  004e3	52		 push	 edx
  004e4	e8 00 00 00 00	 call	 _WriteProgOuts
  004e9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 288  :     fpExp = NewExperimOutFile("testOut", expNo);

  004ec	8b 45 08	 mov	 eax, DWORD PTR _expNo$[ebp]
  004ef	50		 push	 eax
  004f0	68 00 00 00 00	 push	 OFFSET $SG4294967123
  004f5	e8 00 00 00 00	 call	 _NewExperimOutFile
  004fa	83 c4 08	 add	 esp, 8
  004fd	89 45 f0	 mov	 DWORD PTR _fpExp$[ebp], eax

; 289  :     WriteProgOuts(fpExp, testingData, nSamplesTest);

  00500	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nSamplesTest
  00506	51		 push	 ecx
  00507	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _testingData
  0050d	52		 push	 edx
  0050e	8b 45 f0	 mov	 eax, DWORD PTR _fpExp$[ebp]
  00511	50		 push	 eax
  00512	e8 00 00 00 00	 call	 _WriteProgOuts
  00517	83 c4 0c	 add	 esp, 12			; 0000000cH

; 290  : 
; 291  :     nEvalsExp = 0;

  0051a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nEvalsExp, 0

; 292  : }

  00524	8b e5		 mov	 esp, ebp
  00526	5d		 pop	 ebp
  00527	c3		 ret	 0
_RunExperiment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\evolution.c
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_InitDemes PROC

; 525  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 526  : 	register int i, j;
; 527  : 	static unsigned int nTkIndivs;
; 528  : 	
; 529  : 	if (!demes)

  00007	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _demes, 0
  0000e	0f 85 f9 00 00
	00		 jne	 $LN10@InitDemes

; 530  : 	{
; 531  : 		nTkIndivs = 2 * popSize;

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _popSize
  00019	d1 e0		 shl	 eax, 1
  0001b	a3 00 00 00 00	 mov	 DWORD PTR ?nTkIndivs@?1??InitDemes@@9@9, eax

; 532  : 		demes = malloc(nDemes * sizeof(deme));

  00020	6b 0d 00 00 00
	00 60		 imul	 ecx, DWORD PTR _nDemes, 96
  00027	51		 push	 ecx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0002e	83 c4 04	 add	 esp, 4
  00031	a3 00 00 00 00	 mov	 DWORD PTR _demes, eax

; 533  : 		for (i = 0; i < nDemes; i++)

  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003d	eb 09		 jmp	 SHORT $LN12@InitDemes
$LN11@InitDemes:
  0003f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00042	83 c2 01	 add	 edx, 1
  00045	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN12@InitDemes:
  00048	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nDemes
  00051	0f 83 b6 00 00
	00		 jae	 $LN10@InitDemes

; 534  : 		{
; 535  : 			demes[i].qPop = malloc(popSize * qIndivLen * sizeof(qGene));

  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _popSize
  0005d	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR _qIndivLen
  00064	6b d1 0c	 imul	 edx, ecx, 12
  00067	52		 push	 edx
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006e	83 c4 04	 add	 esp, 4
  00071	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  00075	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  0007b	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 536  : 			demes[i].tkPop = malloc(nTkIndivs * sizeof(struct tkIndiv));

  0007e	6b 05 00 00 00
	00 28		 imul	 eax, DWORD PTR ?nTkIndivs@?1??InitDemes@@9@9, 40
  00085	50		 push	 eax
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0008c	83 c4 04	 add	 esp, 4
  0008f	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  00093	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00099	89 44 0a 04	 mov	 DWORD PTR [edx+ecx+4], eax

; 537  : 			demes[i].bestTkIndiv.genome = malloc(qIndivLen * sizeof(int) * 2);

  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR _qIndivLen
  000a2	c1 e0 02	 shl	 eax, 2
  000a5	d1 e0		 shl	 eax, 1
  000a7	50		 push	 eax
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000ae	83 c4 04	 add	 esp, 4
  000b1	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  000b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  000bb	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 538  : 			for (j = 0; j < nTkIndivs; j++)

  000bf	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000c6	eb 09		 jmp	 SHORT $LN9@InitDemes
$LN8@InitDemes:
  000c8	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  000cb	83 c0 01	 add	 eax, 1
  000ce	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN9@InitDemes:
  000d1	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  000d4	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?nTkIndivs@?1??InitDemes@@9@9
  000da	73 2c		 jae	 SHORT $LN7@InitDemes

; 539  : 			{
; 540  : 				demes[i].tkPop[j].genome = malloc(2 * qIndivLen * sizeof(int));

  000dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _qIndivLen
  000e2	d1 e2		 shl	 edx, 1
  000e4	c1 e2 02	 shl	 edx, 2
  000e7	52		 push	 edx
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000ee	83 c4 04	 add	 esp, 4
  000f1	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  000f5	6b 55 f8 28	 imul	 edx, DWORD PTR _j$[ebp], 40
  000f9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _demes
  000ff	8b 4c 0e 04	 mov	 ecx, DWORD PTR [esi+ecx+4]
  00103	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 541  : 			}

  00106	eb c0		 jmp	 SHORT $LN8@InitDemes
$LN7@InitDemes:

; 542  : 		}

  00108	e9 32 ff ff ff	 jmp	 $LN11@InitDemes
$LN10@InitDemes:

; 543  : 	}
; 544  : 	for (i = 0; i < nDemes; i++)

  0010d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00114	eb 09		 jmp	 SHORT $LN6@InitDemes
$LN5@InitDemes:
  00116	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00119	83 c2 01	 add	 edx, 1
  0011c	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN6@InitDemes:
  0011f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00122	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nDemes
  00128	0f 83 ee 01 00
	00		 jae	 $LN4@InitDemes

; 545  : 	{
; 546  : 		for (j = 0; j < popSize; j++)

  0012e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00135	eb 09		 jmp	 SHORT $LN3@InitDemes
$LN2@InitDemes:
  00137	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  0013a	83 c1 01	 add	 ecx, 1
  0013d	89 4d f8	 mov	 DWORD PTR _j$[ebp], ecx
$LN3@InitDemes:
  00140	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  00143	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _popSize
  00149	0f 83 db 00 00
	00		 jae	 $LN1@InitDemes

; 547  : 		{
; 548  : 			InitQIndiv(&(demes[i].qPop[j * qIndivLen]));

  0014f	6b 45 fc 60	 imul	 eax, DWORD PTR _i$[ebp], 96
  00153	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  00156	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR _qIndivLen
  0015d	6b d1 0c	 imul	 edx, ecx, 12
  00160	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  00166	03 14 01	 add	 edx, DWORD PTR [ecx+eax]
  00169	52		 push	 edx
  0016a	e8 00 00 00 00	 call	 _InitQIndiv
  0016f	83 c4 04	 add	 esp, 4

; 549  : 			ObserveQIndiv(&demes[i].qPop[j * qIndivLen], &demes[i].tkPop[j]);

  00172	6b 55 fc 60	 imul	 edx, DWORD PTR _i$[ebp], 96
  00176	6b 45 f8 28	 imul	 eax, DWORD PTR _j$[ebp], 40
  0017a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  00180	03 44 11 04	 add	 eax, DWORD PTR [ecx+edx+4]
  00184	50		 push	 eax
  00185	6b 55 fc 60	 imul	 edx, DWORD PTR _i$[ebp], 96
  00189	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0018c	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _qIndivLen
  00193	6b c8 0c	 imul	 ecx, eax, 12
  00196	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  0019b	03 0c 10	 add	 ecx, DWORD PTR [eax+edx]
  0019e	51		 push	 ecx
  0019f	e8 00 00 00 00	 call	 _ObserveQIndiv
  001a4	83 c4 08	 add	 esp, 8

; 550  : 			demes[i].tkPop[j].fitness = EvalIndivFunc(trainingData, nSamplesTrain, &demes[i].tkPop[j]); // HUGE_VAL;

  001a7	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  001ab	6b 55 f8 28	 imul	 edx, DWORD PTR _j$[ebp], 40
  001af	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  001b4	03 54 08 04	 add	 edx, DWORD PTR [eax+ecx+4]
  001b8	52		 push	 edx
  001b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nSamplesTrain
  001bf	51		 push	 ecx
  001c0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _trainingData
  001c6	52		 push	 edx
  001c7	ff 15 00 00 00
	00		 call	 DWORD PTR _EvalIndivFunc
  001cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d0	6b 45 fc 60	 imul	 eax, DWORD PTR _i$[ebp], 96
  001d4	6b 4d f8 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  001d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  001de	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  001e2	dd 5c 08 08	 fstp	 QWORD PTR [eax+ecx+8]

; 551  : 			demes[i].tkPop[j].validFitness = EvalIndivFunc(validatingData, nSamplesValid, &demes[i].tkPop[j]);

  001e6	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  001ea	6b 55 f8 28	 imul	 edx, DWORD PTR _j$[ebp], 40
  001ee	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  001f3	03 54 08 04	 add	 edx, DWORD PTR [eax+ecx+4]
  001f7	52		 push	 edx
  001f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nSamplesValid
  001fe	51		 push	 ecx
  001ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _validatingData
  00205	52		 push	 edx
  00206	ff 15 00 00 00
	00		 call	 DWORD PTR _EvalIndivFunc
  0020c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020f	6b 45 fc 60	 imul	 eax, DWORD PTR _i$[ebp], 96
  00213	6b 4d f8 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  00217	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  0021d	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00221	dd 5c 08 10	 fstp	 QWORD PTR [eax+ecx+16]

; 552  : 		}

  00225	e9 0d ff ff ff	 jmp	 $LN2@InitDemes
$LN1@InitDemes:

; 553  : 		demes[i].foundBetter = 0;

  0022a	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  0022e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00234	c6 44 0a 31 00	 mov	 BYTE PTR [edx+ecx+49], 0

; 554  : 		demes[i].gwi = 0;

  00239	6b 45 fc 60	 imul	 eax, DWORD PTR _i$[ebp], 96
  0023d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  00243	c7 44 01 34 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+52], 0

; 555  : 		demes[i].gwiMigr = 1;

  0024b	6b 55 fc 60	 imul	 edx, DWORD PTR _i$[ebp], 96
  0024f	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  00254	c7 44 10 38 01
	00 00 00	 mov	 DWORD PTR [eax+edx+56], 1

; 556  : 		demes[i].mustSort = 1;

  0025c	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  00260	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00266	c6 44 0a 30 01	 mov	 BYTE PTR [edx+ecx+48], 1

; 557  : 		demes[i].lGateStep = lGateStep;

  0026b	6b 45 fc 60	 imul	 eax, DWORD PTR _i$[ebp], 96
  0026f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  00275	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _lGateStep
  0027d	f2 0f 11 44 01
	48		 movsd	 QWORD PTR [ecx+eax+72], xmm0

; 558  : 		demes[i].qNopProb = qNopProb;

  00283	6b 55 fc 60	 imul	 edx, DWORD PTR _i$[ebp], 96
  00287	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  0028c	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _qNopProb
  00294	f2 0f 11 44 10
	40		 movsd	 QWORD PTR [eax+edx+64], xmm0

; 559  : 		demes[i].bestTkIndiv.fitness = HUGE_VAL;

  0029a	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  0029e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  002a4	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___HUGE
  002a9	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  002ad	f2 0f 11 44 0a
	10		 movsd	 QWORD PTR [edx+ecx+16], xmm0

; 560  : 		demes[i].bestTkIndiv.validFitness = HUGE_VAL;

  002b3	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  002b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  002bd	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___HUGE
  002c2	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  002c6	f2 0f 11 44 0a
	18		 movsd	 QWORD PTR [edx+ecx+24], xmm0

; 561  : 		demes[i].bestTkIndiv.error = HUGE_VAL;

  002cc	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  002d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  002d6	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___HUGE
  002db	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  002df	f2 0f 11 44 0a
	20		 movsd	 QWORD PTR [edx+ecx+32], xmm0

; 562  : 		demes[i].tmpBestFit = HUGE_VAL;

  002e5	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  002e9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  002ef	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___HUGE
  002f4	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  002f8	f2 0f 11 44 0a
	50		 movsd	 QWORD PTR [edx+ecx+80], xmm0

; 563  : 		demes[i].tmpBestValFit = HUGE_VAL;

  002fe	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  00302	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___HUGE
  0030d	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00311	f2 0f 11 44 0a
	58		 movsd	 QWORD PTR [edx+ecx+88], xmm0

; 564  : 	}

  00317	e9 fa fd ff ff	 jmp	 $LN5@InitDemes
$LN4@InitDemes:

; 565  : }

  0031c	5e		 pop	 esi
  0031d	8b e5		 mov	 esp, ebp
  0031f	5d		 pop	 ebp
  00320	c3		 ret	 0
_InitDemes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\evolution.c
_TEXT	SEGMENT
tv256 = -16						; size = 4
_k$ = -12						; size = 4
_i$ = -8						; size = 4
_j$ = -4						; size = 4
_dIdx$ = 8						; size = 4
_RunDeme PROC

; 760  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 761  : 	register int i, j, k;
; 762  : 	static unsigned int lastTkIndiv;
; 763  : 	static int nTkIndivs;
; 764  : 
; 765  : 	nTkIndivs = 2 * popSize;

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR _popSize
  0000d	d1 e0		 shl	 eax, 1
  0000f	a3 00 00 00 00	 mov	 DWORD PTR ?nTkIndivs@?1??RunDeme@@9@9, eax

; 766  : 	lastTkIndiv = popSize - 1;

  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _popSize
  0001a	83 e9 01	 sub	 ecx, 1
  0001d	89 0d 00 00 00
	00		 mov	 DWORD PTR ?lastTkIndiv@?1??RunDeme@@9@9, ecx

; 767  : 
; 768  : 	demes[dIdx].mustSort = 0;

  00023	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  0002c	c6 44 10 30 00	 mov	 BYTE PTR [eax+edx+48], 0

; 769  : 	demes[dIdx].foundBetter = 0;

  00031	6b 4d 08 60	 imul	 ecx, DWORD PTR _dIdx$[ebp], 96
  00035	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  0003b	c6 44 0a 31 00	 mov	 BYTE PTR [edx+ecx+49], 0

; 770  : 
; 771  : 	if (demes[dIdx].gwi >= 15000) //20000

  00040	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  0004a	81 7c 01 34 98
	3a 00 00	 cmp	 DWORD PTR [ecx+eax+52], 15000 ; 00003a98H
  00052	0f 82 2d 02 00
	00		 jb	 $LN18@RunDeme

; 772  :     {
; 773  : 		k = (dIdx + 1) % (nDemes);

  00058	8b 45 08	 mov	 eax, DWORD PTR _dIdx$[ebp]
  0005b	83 c0 01	 add	 eax, 1
  0005e	33 d2		 xor	 edx, edx
  00060	f7 35 00 00 00
	00		 div	 DWORD PTR _nDemes
  00066	89 55 f4	 mov	 DWORD PTR _k$[ebp], edx

; 774  : 		if (demes[dIdx].bestTkIndiv.fitness < demes[k].bestTkIndiv.fitness)

  00069	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  0006d	6b 45 f4 60	 imul	 eax, DWORD PTR _k$[ebp], 96
  00071	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  00077	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _demes
  0007d	f2 0f 10 44 01
	10		 movsd	 xmm0, QWORD PTR [ecx+eax+16]
  00083	66 0f 2f 44 16
	10		 comisd	 xmm0, QWORD PTR [esi+edx+16]
  00089	76 5b		 jbe	 SHORT $LN17@RunDeme

; 775  : 		{
; 776  : 			CopyTkIndiv(&demes[dIdx].tkPop[0], &demes[dIdx].bestTkIndiv);

  0008b	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  00094	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  00098	51		 push	 ecx
  00099	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  0009d	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  000a2	6b c8 00	 imul	 ecx, eax, 0
  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  000aa	03 4c 10 04	 add	 ecx, DWORD PTR [eax+edx+4]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 _CopyTkIndiv
  000b4	83 c4 08	 add	 esp, 8

; 777  : 			CopyTkIndiv(&demes[dIdx].tkPop[1], &demes[k].bestTkIndiv);

  000b7	6b 4d f4 60	 imul	 ecx, DWORD PTR _k$[ebp], 96
  000bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  000c1	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  000c5	50		 push	 eax
  000c6	6b 4d 08 60	 imul	 ecx, DWORD PTR _dIdx$[ebp], 96
  000ca	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  000cf	c1 e2 00	 shl	 edx, 0
  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  000d7	03 54 08 04	 add	 edx, DWORD PTR [eax+ecx+4]
  000db	52		 push	 edx
  000dc	e8 00 00 00 00	 call	 _CopyTkIndiv
  000e1	83 c4 08	 add	 esp, 8

; 778  : 		}
; 779  : 		else

  000e4	eb 5c		 jmp	 SHORT $LN16@RunDeme
$LN17@RunDeme:

; 780  : 		{
; 781  : 			CopyTkIndiv(&demes[dIdx].tkPop[0], &demes[k].bestTkIndiv);

  000e6	6b 4d f4 60	 imul	 ecx, DWORD PTR _k$[ebp], 96
  000ea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  000f0	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  000f4	50		 push	 eax
  000f5	6b 4d 08 60	 imul	 ecx, DWORD PTR _dIdx$[ebp], 96
  000f9	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  000fe	6b c2 00	 imul	 eax, edx, 0
  00101	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00107	03 44 0a 04	 add	 eax, DWORD PTR [edx+ecx+4]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 _CopyTkIndiv
  00111	83 c4 08	 add	 esp, 8

; 782  : 			CopyTkIndiv(&demes[dIdx].tkPop[1], &demes[dIdx].bestTkIndiv);

  00114	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  00118	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  0011e	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00122	52		 push	 edx
  00123	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  00127	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0012c	c1 e1 00	 shl	 ecx, 0
  0012f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00135	03 4c 02 04	 add	 ecx, DWORD PTR [edx+eax+4]
  00139	51		 push	 ecx
  0013a	e8 00 00 00 00	 call	 _CopyTkIndiv
  0013f	83 c4 08	 add	 esp, 8
$LN16@RunDeme:

; 783  : 		}
; 784  : 		ResetQIndiv(&demes[dIdx].qPop[0]);

  00142	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  00146	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0014b	6b d1 00	 imul	 edx, ecx, 0
  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  00154	03 14 01	 add	 edx, DWORD PTR [ecx+eax]
  00157	52		 push	 edx
  00158	e8 00 00 00 00	 call	 _ResetQIndiv
  0015d	83 c4 04	 add	 esp, 4

; 785  : 		/*ResetQIndiv(&demes[dIdx].qPop[qIndivLen]);*/
; 786  : 		lGateStep = 1;

  00160	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00168	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _lGateStep, xmm0

; 787  : 		LGateNoNorm(&(demes[dIdx].qPop[0])        , &demes[dIdx].tkPop[0]);

  00170	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  00174	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  00179	6b c8 00	 imul	 ecx, eax, 0
  0017c	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  00181	03 4c 10 04	 add	 ecx, DWORD PTR [eax+edx+4]
  00185	51		 push	 ecx
  00186	6b 4d 08 60	 imul	 ecx, DWORD PTR _dIdx$[ebp], 96
  0018a	ba 0c 00 00 00	 mov	 edx, 12			; 0000000cH
  0018f	6b c2 00	 imul	 eax, edx, 0
  00192	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00198	03 04 0a	 add	 eax, DWORD PTR [edx+ecx]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 _LGateNoNorm
  001a1	83 c4 08	 add	 esp, 8

; 788  : 		//LGateNoNorm(&(demes[dIdx].qPop[qIndivLen]), &demes[dIdx].tkPop[1]);
; 789  : 		lGateStep = 0.004;

  001a4	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f70624dd2f1a9fc
  001ac	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _lGateStep, xmm0

; 790  : 		//for (i = 2; i < popSize; i++)
; 791  : 		for (i = 1; i < popSize; i++)

  001b4	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  001bb	eb 09		 jmp	 SHORT $LN15@RunDeme
$LN14@RunDeme:
  001bd	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001c0	83 c0 01	 add	 eax, 1
  001c3	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN15@RunDeme:
  001c6	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  001c9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _popSize
  001cf	0f 83 8d 00 00
	00		 jae	 $LN13@RunDeme

; 792  : 		{
; 793  :             demes[dIdx].tkPop[i].fitness = HUGE_VAL;

  001d5	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  001d9	6b 45 f8 28	 imul	 eax, DWORD PTR _i$[ebp], 40
  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  001e3	8b 54 11 04	 mov	 edx, DWORD PTR [ecx+edx+4]
  001e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___HUGE
  001ed	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  001f1	f2 0f 11 44 02
	08		 movsd	 QWORD PTR [edx+eax+8], xmm0

; 794  :             demes[dIdx].tkPop[i].validFitness = HUGE_VAL;

  001f7	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  001fb	6b 45 f8 28	 imul	 eax, DWORD PTR _i$[ebp], 40
  001ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  00205	8b 54 11 04	 mov	 edx, DWORD PTR [ecx+edx+4]
  00209	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___HUGE
  0020f	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  00213	f2 0f 11 44 02
	10		 movsd	 QWORD PTR [edx+eax+16], xmm0

; 795  : 			demes[dIdx].tkPop[i].error = HUGE_VAL;

  00219	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  0021d	6b 45 f8 28	 imul	 eax, DWORD PTR _i$[ebp], 40
  00221	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  00227	8b 54 11 04	 mov	 edx, DWORD PTR [ecx+edx+4]
  0022b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___HUGE
  00231	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  00235	f2 0f 11 44 02
	18		 movsd	 QWORD PTR [edx+eax+24], xmm0

; 796  : 			ResetQIndiv(&demes[dIdx].qPop[i * qIndivLen]);

  0023b	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  0023f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00242	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _qIndivLen
  00249	6b c8 0c	 imul	 ecx, eax, 12
  0024c	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  00251	03 0c 10	 add	 ecx, DWORD PTR [eax+edx]
  00254	51		 push	 ecx
  00255	e8 00 00 00 00	 call	 _ResetQIndiv
  0025a	83 c4 04	 add	 esp, 4

; 797  :         }

  0025d	e9 5b ff ff ff	 jmp	 $LN14@RunDeme
$LN13@RunDeme:

; 798  : 		printf("D%d Rst;  ", dIdx);

  00262	8b 4d 08	 mov	 ecx, DWORD PTR _dIdx$[ebp]
  00265	51		 push	 ecx
  00266	68 00 00 00 00	 push	 OFFSET $SG4294967118
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00271	83 c4 08	 add	 esp, 8

; 799  : 		demes[dIdx].gwi = 0;

  00274	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  00278	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  0027d	c7 44 10 34 00
	00 00 00	 mov	 DWORD PTR [eax+edx+52], 0
$LN18@RunDeme:

; 800  :     }
; 801  : 
; 802  :     for (i = 0, j = popSize; i < popSize; i++, j++)

  00285	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0028c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _popSize
  00292	89 4d fc	 mov	 DWORD PTR _j$[ebp], ecx
  00295	eb 12		 jmp	 SHORT $LN12@RunDeme
$LN11@RunDeme:
  00297	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0029a	83 c2 01	 add	 edx, 1
  0029d	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  002a0	8b 45 fc	 mov	 eax, DWORD PTR _j$[ebp]
  002a3	83 c0 01	 add	 eax, 1
  002a6	89 45 fc	 mov	 DWORD PTR _j$[ebp], eax
$LN12@RunDeme:
  002a9	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  002ac	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _popSize
  002b2	0f 83 99 03 00
	00		 jae	 $LN10@RunDeme

; 803  : 	{
; 804  : 		ObserveQIndivFunc(&demes[dIdx].qPop[i * qIndivLen], &demes[dIdx].tkPop[j]);

  002b8	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  002bc	6b 45 fc 28	 imul	 eax, DWORD PTR _j$[ebp], 40
  002c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  002c6	03 44 11 04	 add	 eax, DWORD PTR [ecx+edx+4]
  002ca	50		 push	 eax
  002cb	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  002cf	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  002d2	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _qIndivLen
  002d9	6b c8 0c	 imul	 ecx, eax, 12
  002dc	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  002e1	03 0c 10	 add	 ecx, DWORD PTR [eax+edx]
  002e4	51		 push	 ecx
  002e5	ff 15 00 00 00
	00		 call	 DWORD PTR _ObserveQIndivFunc
  002eb	83 c4 08	 add	 esp, 8

; 805  : 		demes[dIdx].tkPop[j].fitness = EvalIndivFunc(trainingData, nSamplesTrain, &demes[dIdx].tkPop[j]);

  002ee	6b 4d 08 60	 imul	 ecx, DWORD PTR _dIdx$[ebp], 96
  002f2	6b 55 fc 28	 imul	 edx, DWORD PTR _j$[ebp], 40
  002f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  002fb	03 54 08 04	 add	 edx, DWORD PTR [eax+ecx+4]
  002ff	52		 push	 edx
  00300	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nSamplesTrain
  00306	51		 push	 ecx
  00307	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _trainingData
  0030d	52		 push	 edx
  0030e	ff 15 00 00 00
	00		 call	 DWORD PTR _EvalIndivFunc
  00314	83 c4 0c	 add	 esp, 12			; 0000000cH
  00317	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  0031b	6b 4d fc 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  0031f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00325	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00329	dd 5c 08 08	 fstp	 QWORD PTR [eax+ecx+8]

; 806  :         nEvaluations++;

  0032d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nEvaluations
  00333	83 c1 01	 add	 ecx, 1
  00336	89 0d 00 00 00
	00		 mov	 DWORD PTR _nEvaluations, ecx

; 807  :         nEvalsExp++;

  0033c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nEvalsExp
  00342	83 c2 01	 add	 edx, 1
  00345	89 15 00 00 00
	00		 mov	 DWORD PTR _nEvalsExp, edx

; 808  : 
; 809  : 		demes[dIdx].mustSort = (demes[dIdx].tkPop[j].fitness <= demes[dIdx].tkPop[lastTkIndiv].fitness);

  0034b	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  0034f	6b 4d fc 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  00353	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00359	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  0035d	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  00361	6b 35 00 00 00
	00 28		 imul	 esi, DWORD PTR ?lastTkIndiv@?1??RunDeme@@9@9, 40
  00368	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _demes
  0036e	8b 54 17 04	 mov	 edx, DWORD PTR [edi+edx+4]
  00372	f2 0f 10 44 32
	08		 movsd	 xmm0, QWORD PTR [edx+esi+8]
  00378	66 0f 2f 44 08
	08		 comisd	 xmm0, QWORD PTR [eax+ecx+8]
  0037e	72 09		 jb	 SHORT $LN21@RunDeme
  00380	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv256[ebp], 1
  00387	eb 07		 jmp	 SHORT $LN22@RunDeme
$LN21@RunDeme:
  00389	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv256[ebp], 0
$LN22@RunDeme:
  00390	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  00394	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  0039a	8a 55 f0	 mov	 dl, BYTE PTR tv256[ebp]
  0039d	88 54 01 30	 mov	 BYTE PTR [ecx+eax+48], dl

; 810  : 		
; 811  : 		if (demes[dIdx].tkPop[j].fitness <= demes[dIdx].bestTkIndiv.fitness)

  003a1	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  003a5	6b 4d fc 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  003a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  003af	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  003b3	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  003b7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _demes
  003bd	f2 0f 10 44 16
	10		 movsd	 xmm0, QWORD PTR [esi+edx+16]
  003c3	66 0f 2f 44 08
	08		 comisd	 xmm0, QWORD PTR [eax+ecx+8]
  003c9	0f 82 7d 02 00
	00		 jb	 $LN5@RunDeme

; 812  : 		{
; 813  :                 demes[dIdx].tkPop[j].validFitness = EvalIndivFunc(validatingData, nSamplesValid, &demes[dIdx].tkPop[j]);

  003cf	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  003d3	6b 4d fc 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  003d7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  003dd	03 4c 02 04	 add	 ecx, DWORD PTR [edx+eax+4]
  003e1	51		 push	 ecx
  003e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _nSamplesValid
  003e7	50		 push	 eax
  003e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validatingData
  003ee	51		 push	 ecx
  003ef	ff 15 00 00 00
	00		 call	 DWORD PTR _EvalIndivFunc
  003f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  003f8	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  003fc	6b 45 fc 28	 imul	 eax, DWORD PTR _j$[ebp], 40
  00400	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  00406	8b 54 11 04	 mov	 edx, DWORD PTR [ecx+edx+4]
  0040a	dd 5c 02 10	 fstp	 QWORD PTR [edx+eax+16]

; 814  : 				//TODO: isBetter()
; 815  : 			    if (demes[dIdx].tkPop[j].validFitness < demes[dIdx].bestTkIndiv.validFitness ||
; 816  : 					(demes[dIdx].tkPop[j].fitness < demes[dIdx].bestTkIndiv.fitness && 
; 817  : 					 demes[dIdx].tkPop[j].validFitness < demes[dIdx].bestTkIndiv.fitness))

  0040e	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  00412	6b 4d fc 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  00416	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  0041c	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00420	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  00424	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _demes
  0042a	f2 0f 10 44 16
	18		 movsd	 xmm0, QWORD PTR [esi+edx+24]
  00430	66 0f 2f 44 08
	10		 comisd	 xmm0, QWORD PTR [eax+ecx+16]
  00436	77 5c		 ja	 SHORT $LN7@RunDeme
  00438	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  0043c	6b 4d fc 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  00440	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00446	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  0044a	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  0044e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _demes
  00454	f2 0f 10 44 16
	10		 movsd	 xmm0, QWORD PTR [esi+edx+16]
  0045a	66 0f 2f 44 08
	08		 comisd	 xmm0, QWORD PTR [eax+ecx+8]
  00460	0f 86 e5 00 00
	00		 jbe	 $LN8@RunDeme
  00466	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  0046a	6b 4d fc 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  0046e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00474	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00478	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  0047c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _demes
  00482	f2 0f 10 44 16
	10		 movsd	 xmm0, QWORD PTR [esi+edx+16]
  00488	66 0f 2f 44 08
	10		 comisd	 xmm0, QWORD PTR [eax+ecx+16]
  0048e	0f 86 b7 00 00
	00		 jbe	 $LN8@RunDeme
$LN7@RunDeme:

; 818  : 				{
; 819  : 					printf("D%i L=%i T=%.4f V=%.4f;  ", dIdx, demes[dIdx].tkPop[j].length, 
; 820  : 						demes[dIdx].tkPop[j].fitness, demes[dIdx].tkPop[j].validFitness);

  00494	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  00498	6b 4d fc 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  0049c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  004a2	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  004a6	83 ec 08	 sub	 esp, 8
  004a9	f2 0f 10 44 08
	10		 movsd	 xmm0, QWORD PTR [eax+ecx+16]
  004af	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  004b4	6b 4d 08 60	 imul	 ecx, DWORD PTR _dIdx$[ebp], 96
  004b8	6b 55 fc 28	 imul	 edx, DWORD PTR _j$[ebp], 40
  004bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  004c1	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  004c5	83 ec 08	 sub	 esp, 8
  004c8	f2 0f 10 44 11
	08		 movsd	 xmm0, QWORD PTR [ecx+edx+8]
  004ce	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  004d3	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  004d7	6b 45 fc 28	 imul	 eax, DWORD PTR _j$[ebp], 40
  004db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  004e1	8b 54 11 04	 mov	 edx, DWORD PTR [ecx+edx+4]
  004e5	0f b6 44 02 20	 movzx	 eax, BYTE PTR [edx+eax+32]
  004ea	50		 push	 eax
  004eb	8b 4d 08	 mov	 ecx, DWORD PTR _dIdx$[ebp]
  004ee	51		 push	 ecx
  004ef	68 00 00 00 00	 push	 OFFSET $SG4294967117
  004f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  004fa	83 c4 1c	 add	 esp, 28			; 0000001cH

; 821  :                     CopyTkIndiv(&demes[dIdx].bestTkIndiv, &demes[dIdx].tkPop[j]);

  004fd	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  00501	6b 45 fc 28	 imul	 eax, DWORD PTR _j$[ebp], 40
  00505	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  0050b	03 44 11 04	 add	 eax, DWORD PTR [ecx+edx+4]
  0050f	50		 push	 eax
  00510	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  00514	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  00519	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  0051d	51		 push	 ecx
  0051e	e8 00 00 00 00	 call	 _CopyTkIndiv
  00523	83 c4 08	 add	 esp, 8

; 822  :                     demes[dIdx].foundBetter = 1;

  00526	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  0052a	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  0052f	c6 44 10 31 01	 mov	 BYTE PTR [eax+edx+49], 1

; 823  : 					demes[dIdx].gwi = 0;

  00534	6b 4d 08 60	 imul	 ecx, DWORD PTR _dIdx$[ebp], 96
  00538	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  0053e	c7 44 0a 34 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+52], 0

; 824  : 				}
; 825  : 				else

  00546	e9 01 01 00 00	 jmp	 $LN5@RunDeme
$LN8@RunDeme:

; 826  : 				{
; 827  : 					
; 828  : 						if (demes[dIdx].tkPop[j].fitness == demes[dIdx].bestTkIndiv.fitness &&
; 829  : 					        demes[dIdx].tkPop[j].validFitness == demes[dIdx].bestTkIndiv.validFitness &&
; 830  : 							demes[dIdx].tkPop[j].length < demes[dIdx].bestTkIndiv.length) //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  0054b	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  0054f	6b 4d fc 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  00553	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00559	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  0055d	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  00561	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _demes
  00567	f2 0f 10 44 08
	08		 movsd	 xmm0, QWORD PTR [eax+ecx+8]
  0056d	66 0f 2e 44 16
	10		 ucomisd xmm0, QWORD PTR [esi+edx+16]
  00573	9f		 lahf
  00574	f6 c4 44	 test	 ah, 68			; 00000044H
  00577	0f 8a cf 00 00
	00		 jp	 $LN5@RunDeme
  0057d	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  00581	6b 4d fc 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  00585	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  0058b	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  0058f	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  00593	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _demes
  00599	f2 0f 10 44 08
	10		 movsd	 xmm0, QWORD PTR [eax+ecx+16]
  0059f	66 0f 2e 44 16
	18		 ucomisd xmm0, QWORD PTR [esi+edx+24]
  005a5	9f		 lahf
  005a6	f6 c4 44	 test	 ah, 68			; 00000044H
  005a9	0f 8a 9d 00 00
	00		 jp	 $LN5@RunDeme
  005af	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  005b3	6b 4d fc 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  005b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  005bd	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  005c1	0f b6 4c 08 20	 movzx	 ecx, BYTE PTR [eax+ecx+32]
  005c6	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  005ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  005cf	0f b6 54 10 28	 movzx	 edx, BYTE PTR [eax+edx+40]
  005d4	3b ca		 cmp	 ecx, edx
  005d6	7d 74		 jge	 SHORT $LN5@RunDeme

; 831  : 						{
; 832  : 							printf("D%i L=%i;  ", dIdx, demes[dIdx].tkPop[j].length);

  005d8	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  005dc	6b 4d fc 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  005e0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  005e6	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  005ea	0f b6 4c 08 20	 movzx	 ecx, BYTE PTR [eax+ecx+32]
  005ef	51		 push	 ecx
  005f0	8b 55 08	 mov	 edx, DWORD PTR _dIdx$[ebp]
  005f3	52		 push	 edx
  005f4	68 00 00 00 00	 push	 OFFSET $SG4294967116
  005f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  005ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 833  :                             CopyTkIndiv(&demes[dIdx].bestTkIndiv, &demes[dIdx].tkPop[j]);

  00602	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  00606	6b 4d fc 28	 imul	 ecx, DWORD PTR _j$[ebp], 40
  0060a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00610	03 4c 02 04	 add	 ecx, DWORD PTR [edx+eax+4]
  00614	51		 push	 ecx
  00615	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  00619	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  0061f	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00623	52		 push	 edx
  00624	e8 00 00 00 00	 call	 _CopyTkIndiv
  00629	83 c4 08	 add	 esp, 8

; 834  :                             demes[dIdx].foundBetter = 1;

  0062c	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  00630	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  00636	c6 44 01 31 01	 mov	 BYTE PTR [ecx+eax+49], 1

; 835  : 							demes[dIdx].gwi = 0;

  0063b	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  0063f	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  00644	c7 44 10 34 00
	00 00 00	 mov	 DWORD PTR [eax+edx+52], 0
$LN5@RunDeme:

; 836  : 						}
; 837  : 					
; 838  : 				}
; 839  : 		}
; 840  : 	}

  0064c	e9 46 fc ff ff	 jmp	 $LN11@RunDeme
$LN10@RunDeme:

; 841  : 	if (demes[dIdx].mustSort)

  00651	6b 4d 08 60	 imul	 ecx, DWORD PTR _dIdx$[ebp], 96
  00655	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  0065b	0f b6 44 0a 30	 movzx	 eax, BYTE PTR [edx+ecx+48]
  00660	85 c0		 test	 eax, eax
  00662	74 2b		 je	 SHORT $LN4@RunDeme

; 842  : 	{
; 843  : 		InsertSortLen(demes[dIdx].tkPop, nTkIndivs);

  00664	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nTkIndivs@?1??RunDeme@@9@9
  0066a	51		 push	 ecx
  0066b	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  0066f	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  00674	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  00678	51		 push	 ecx
  00679	e8 00 00 00 00	 call	 _InsertSortLen
  0067e	83 c4 08	 add	 esp, 8

; 844  : 		demes[dIdx].mustSort = 0;

  00681	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  00685	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  0068a	c6 44 10 30 00	 mov	 BYTE PTR [eax+edx+48], 0
$LN4@RunDeme:

; 845  : 	}
; 846  : 	
; 847  : 	NoRepeat(demes[dIdx].tkPop, nTkIndivs); //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  0068f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nTkIndivs@?1??RunDeme@@9@9
  00695	51		 push	 ecx
  00696	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  0069a	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  0069f	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  006a3	51		 push	 ecx
  006a4	e8 00 00 00 00	 call	 _NoRepeat
  006a9	83 c4 08	 add	 esp, 8

; 848  : 		
; 849  :     for (i = 0; i < popSize; i++)

  006ac	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  006b3	eb 09		 jmp	 SHORT $LN3@RunDeme
$LN2@RunDeme:
  006b5	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  006b8	83 c2 01	 add	 edx, 1
  006bb	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN3@RunDeme:
  006be	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  006c1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _popSize
  006c7	73 37		 jae	 SHORT $LN1@RunDeme

; 850  :     {
; 851  :         LGateNoNorm(&(demes[dIdx].qPop[i * qIndivLen]), &(demes[dIdx].tkPop[i]));

  006c9	6b 4d 08 60	 imul	 ecx, DWORD PTR _dIdx$[ebp], 96
  006cd	6b 55 f8 28	 imul	 edx, DWORD PTR _i$[ebp], 40
  006d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  006d6	03 54 08 04	 add	 edx, DWORD PTR [eax+ecx+4]
  006da	52		 push	 edx
  006db	6b 4d 08 60	 imul	 ecx, DWORD PTR _dIdx$[ebp], 96
  006df	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  006e2	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR _qIndivLen
  006e9	6b c2 0c	 imul	 eax, edx, 12
  006ec	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  006f2	03 04 0a	 add	 eax, DWORD PTR [edx+ecx]
  006f5	50		 push	 eax
  006f6	e8 00 00 00 00	 call	 _LGateNoNorm
  006fb	83 c4 08	 add	 esp, 8

; 852  :     }

  006fe	eb b5		 jmp	 SHORT $LN2@RunDeme
$LN1@RunDeme:

; 853  : 	demes[dIdx].gwi++;

  00700	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  00704	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  0070a	8b 54 01 34	 mov	 edx, DWORD PTR [ecx+eax+52]
  0070e	83 c2 01	 add	 edx, 1
  00711	6b 45 08 60	 imul	 eax, DWORD PTR _dIdx$[ebp], 96
  00715	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  0071b	89 54 01 34	 mov	 DWORD PTR [ecx+eax+52], edx

; 854  : 
; 855  : 	return demes[dIdx].foundBetter;

  0071f	6b 55 08 60	 imul	 edx, DWORD PTR _dIdx$[ebp], 96
  00723	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  00728	8a 44 10 31	 mov	 al, BYTE PTR [eax+edx+49]

; 856  : }

  0072c	5f		 pop	 edi
  0072d	5e		 pop	 esi
  0072e	8b e5		 mov	 esp, ebp
  00730	5d		 pop	 ebp
  00731	c3		 ret	 0
_RunDeme ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\evolution.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_gen$ = 8						; size = 4
_expBestFit$ = 12					; size = 4
_RunGenerationDemes PROC

; 859  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 860  : 	register int i;
; 861  : 
; 862  : 	for (i = 0; i < nDemes; i++)

  00005	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000c	eb 09		 jmp	 SHORT $LN10@RunGenerat
$LN9@RunGenerat:
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00011	83 c0 01	 add	 eax, 1
  00014	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN10@RunGenerat:
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _nDemes
  00020	0f 83 b8 00 00
	00		 jae	 $LN8@RunGenerat

; 863  : 	{
; 864  : 		if(RunDeme(i))

  00026	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 _RunDeme
  0002f	83 c4 04	 add	 esp, 4
  00032	0f b6 c0	 movzx	 eax, al
  00035	85 c0		 test	 eax, eax
  00037	0f 84 9c 00 00
	00		 je	 $LN6@RunGenerat

; 865  : 		{
; 866  : 			if((demes[i].bestTkIndiv.fitness <= bestExpTkIndiv.fitness &&
; 867  :                 demes[i].bestTkIndiv.validFitness < bestExpTkIndiv.validFitness) ||
; 868  : 			   (demes[i].bestTkIndiv.fitness < bestExpTkIndiv.fitness &&
; 869  : 			    demes[i].bestTkIndiv.validFitness < demes[i].bestTkIndiv.fitness))

  0003d	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  00041	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  00047	f2 0f 10 05 08
	00 00 00	 movsd	 xmm0, QWORD PTR _bestExpTkIndiv+8
  0004f	66 0f 2f 44 0a
	10		 comisd	 xmm0, QWORD PTR [edx+ecx+16]
  00055	72 1a		 jb	 SHORT $LN4@RunGenerat
  00057	6b 45 fc 60	 imul	 eax, DWORD PTR _i$[ebp], 96
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _demes
  00061	f2 0f 10 05 10
	00 00 00	 movsd	 xmm0, QWORD PTR _bestExpTkIndiv+16
  00069	66 0f 2f 44 01
	18		 comisd	 xmm0, QWORD PTR [ecx+eax+24]
  0006f	77 3a		 ja	 SHORT $LN5@RunGenerat
$LN4@RunGenerat:
  00071	6b 55 fc 60	 imul	 edx, DWORD PTR _i$[ebp], 96
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  0007a	f2 0f 10 05 08
	00 00 00	 movsd	 xmm0, QWORD PTR _bestExpTkIndiv+8
  00082	66 0f 2f 44 10
	10		 comisd	 xmm0, QWORD PTR [eax+edx+16]
  00088	76 4f		 jbe	 SHORT $LN6@RunGenerat
  0008a	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  0008e	6b 55 fc 60	 imul	 edx, DWORD PTR _i$[ebp], 96
  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _demes
  00097	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _demes
  0009d	f2 0f 10 44 10
	10		 movsd	 xmm0, QWORD PTR [eax+edx+16]
  000a3	66 0f 2f 44 0e
	18		 comisd	 xmm0, QWORD PTR [esi+ecx+24]
  000a9	76 2e		 jbe	 SHORT $LN6@RunGenerat
$LN5@RunGenerat:

; 870  : 			{
; 871  : 				CopyTkIndiv(&bestExpTkIndiv, &demes[i].bestTkIndiv);

  000ab	6b 4d fc 60	 imul	 ecx, DWORD PTR _i$[ebp], 96
  000af	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _demes
  000b5	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  000b9	50		 push	 eax
  000ba	68 00 00 00 00	 push	 OFFSET _bestExpTkIndiv
  000bf	e8 00 00 00 00	 call	 _CopyTkIndiv
  000c4	83 c4 08	 add	 esp, 8

; 872  : 				printf("<= G=%i Best!  ", gen);

  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _gen$[ebp]
  000ca	51		 push	 ecx
  000cb	68 00 00 00 00	 push	 OFFSET $SG4294967115
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000d6	83 c4 08	 add	 esp, 8
$LN6@RunGenerat:

; 873  : 			}
; 874  : 		}
; 875  : 	}

  000d9	e9 30 ff ff ff	 jmp	 $LN9@RunGenerat
$LN8@RunGenerat:

; 876  : 	if((bestExpTkIndiv.fitness <= bestTkIndiv.fitness &&
; 877  : 	    bestExpTkIndiv.validFitness < bestTkIndiv.validFitness) ||
; 878  : 	   (bestExpTkIndiv.fitness < bestTkIndiv.fitness && 
; 879  : 	    bestExpTkIndiv.validFitness < bestTkIndiv.fitness))

  000de	f2 0f 10 05 08
	00 00 00	 movsd	 xmm0, QWORD PTR _bestTkIndiv+8
  000e6	66 0f 2f 05 08
	00 00 00	 comisd	 xmm0, QWORD PTR _bestExpTkIndiv+8
  000ee	72 12		 jb	 SHORT $LN1@RunGenerat
  000f0	f2 0f 10 05 10
	00 00 00	 movsd	 xmm0, QWORD PTR _bestTkIndiv+16
  000f8	66 0f 2f 05 10
	00 00 00	 comisd	 xmm0, QWORD PTR _bestExpTkIndiv+16
  00100	77 24		 ja	 SHORT $LN2@RunGenerat
$LN1@RunGenerat:
  00102	f2 0f 10 05 08
	00 00 00	 movsd	 xmm0, QWORD PTR _bestTkIndiv+8
  0010a	66 0f 2f 05 08
	00 00 00	 comisd	 xmm0, QWORD PTR _bestExpTkIndiv+8
  00112	76 24		 jbe	 SHORT $LN3@RunGenerat
  00114	f2 0f 10 05 08
	00 00 00	 movsd	 xmm0, QWORD PTR _bestTkIndiv+8
  0011c	66 0f 2f 05 10
	00 00 00	 comisd	 xmm0, QWORD PTR _bestExpTkIndiv+16
  00124	76 12		 jbe	 SHORT $LN3@RunGenerat
$LN2@RunGenerat:

; 880  : 	{
; 881  : 		CopyTkIndiv(&bestTkIndiv, &bestExpTkIndiv);

  00126	68 00 00 00 00	 push	 OFFSET _bestExpTkIndiv
  0012b	68 00 00 00 00	 push	 OFFSET _bestTkIndiv
  00130	e8 00 00 00 00	 call	 _CopyTkIndiv
  00135	83 c4 08	 add	 esp, 8
$LN3@RunGenerat:

; 882  : 	}
; 883  : }

  00138	5e		 pop	 esi
  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c3		 ret	 0
_RunGenerationDemes ENDP
_TEXT	ENDS
END
