; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	D:\JOCHO\sanpa\seminario de tesis\QILGP\QILGP\indiv.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp__fabs:PROC
EXTRN	__imp___finite:PROC
$SG4294966774 DB '%x ', 00H
PUBLIC	_InitIndiv
PUBLIC	_CopyTkIndiv
PUBLIC	_EvalIndiv
PUBLIC	_EvalIndivHitRate
PUBLIC	_Assemble
PUBLIC	_RunCase
?idx@?1??EvalIndiv@@9@9 DD 01H DUP (?)			; `EvalIndiv'::`2'::idx
_BSS	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\indiv.c
_TEXT	SEGMENT
_v$ = 8							; size = 4
_RunCase PROC

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 35   : 	typedef void(* pFunction)(v);
; 36   : 
; 37   : 	//static short unsigned int cw = 0x037a;
; 38   : 	_asm fninit	

  00003	db e3		 fninit

; 39   : 	//_asm fldcw [cw]
; 40   : 
; 41   : 	((pFunction) indiv)(v);

  00005	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR _indiv
  0000f	83 c4 04	 add	 esp, 4

; 42   : 	if (!_finite(v[0]))

  00012	b9 04 00 00 00	 mov	 ecx, 4
  00017	6b d1 00	 imul	 edx, ecx, 0
  0001a	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0001d	f3 0f 5a 04 10	 cvtss2sd xmm0, DWORD PTR [eax+edx]
  00022	83 ec 08	 sub	 esp, 8
  00025	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___finite
  00030	83 c4 08	 add	 esp, 8
  00033	85 c0		 test	 eax, eax
  00035	75 18		 jne	 SHORT $LN1@RunCase

; 43   : 	{
; 44   : 		v[0]=0;

  00037	b9 04 00 00 00	 mov	 ecx, 4
  0003c	6b d1 00	 imul	 edx, ecx, 0
  0003f	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00042	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0004a	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
$LN1@RunCase:

; 45   : 	}
; 46   : }

  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_RunCase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\indiv.c
_TEXT	SEGMENT
_len$ = -28						; size = 4
_terms$ = -24						; size = 4
_j$ = -20						; size = 4
_b$ = -16						; size = 4
_i$ = -12						; size = 4
_m$ = -8						; size = 4
_funcToken$ = -2					; size = 1
_termToken$ = -1					; size = 1
__tkIndiv$ = 8						; size = 4
_Assemble PROC

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 50   : 	int i, j, b;
; 51   : 	int m;
; 52   :     int len;
; 53   : 	byte funcToken;
; 54   : 	byte termToken = 0;

  00006	c6 45 ff 00	 mov	 BYTE PTR _termToken$[ebp], 0

; 55   : 	byteList *terms;
; 56   : 	
; 57   : 	_tkIndiv->length = 0;

  0000a	8b 45 08	 mov	 eax, DWORD PTR __tkIndiv$[ebp]
  0000d	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0

; 58   : 	m = headerLen;

  00011	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _headerLen
  00018	89 4d f8	 mov	 DWORD PTR _m$[ebp], ecx

; 59   :     len = qIndivLen * 2;

  0001b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _qIndivLen
  00021	d1 e2		 shl	 edx, 1
  00023	89 55 e4	 mov	 DWORD PTR _len$[ebp], edx

; 60   : 
; 61   : 	for (i = 0; i < len; i+=2)

  00026	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002d	eb 09		 jmp	 SHORT $LN10@Assemble
$LN9@Assemble:
  0002f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00032	83 c0 02	 add	 eax, 2
  00035	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN10@Assemble:
  00038	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0003b	3b 4d e4	 cmp	 ecx, DWORD PTR _len$[ebp]
  0003e	0f 8d 90 00 00
	00		 jge	 $LN8@Assemble

; 62   : 	{
; 63   : 		funcToken = *(_tkIndiv->genome + i);

  00044	8b 55 08	 mov	 edx, DWORD PTR __tkIndiv$[ebp]
  00047	8b 02		 mov	 eax, DWORD PTR [edx]
  00049	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0004c	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  0004f	88 55 fe	 mov	 BYTE PTR _funcToken$[ebp], dl

; 64   : 		if (funcToken > 0)

  00052	0f b6 45 fe	 movzx	 eax, BYTE PTR _funcToken$[ebp]
  00056	85 c0		 test	 eax, eax
  00058	7e 75		 jle	 SHORT $LN7@Assemble

; 65   : 		{
; 66   : 			_tkIndiv->length++;

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR __tkIndiv$[ebp]
  0005d	8a 51 20	 mov	 dl, BYTE PTR [ecx+32]
  00060	80 c2 01	 add	 dl, 1
  00063	8b 45 08	 mov	 eax, DWORD PTR __tkIndiv$[ebp]
  00066	88 50 20	 mov	 BYTE PTR [eax+32], dl

; 67   : 			termToken = *(_tkIndiv->genome + i + 1);

  00069	8b 4d 08	 mov	 ecx, DWORD PTR __tkIndiv$[ebp]
  0006c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006e	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00071	8a 4c 02 01	 mov	 cl, BYTE PTR [edx+eax+1]
  00075	88 4d ff	 mov	 BYTE PTR _termToken$[ebp], cl

; 68   : 			terms = sintTable[funcToken];

  00078	0f b6 55 fe	 movzx	 edx, BYTE PTR _funcToken$[ebp]
  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR _sintTable
  00081	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00084	89 4d e8	 mov	 DWORD PTR _terms$[ebp], ecx

; 69   : 			for (b = 0; b < terms[termToken].length; b++, m++)

  00087	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _b$[ebp], 0
  0008e	eb 12		 jmp	 SHORT $LN6@Assemble
$LN5@Assemble:
  00090	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  00093	83 c2 01	 add	 edx, 1
  00096	89 55 f0	 mov	 DWORD PTR _b$[ebp], edx
  00099	8b 45 f8	 mov	 eax, DWORD PTR _m$[ebp]
  0009c	83 c0 01	 add	 eax, 1
  0009f	89 45 f8	 mov	 DWORD PTR _m$[ebp], eax
$LN6@Assemble:
  000a2	0f b6 4d ff	 movzx	 ecx, BYTE PTR _termToken$[ebp]
  000a6	8b 55 e8	 mov	 edx, DWORD PTR _terms$[ebp]
  000a9	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  000ac	3b 44 ca 04	 cmp	 eax, DWORD PTR [edx+ecx*8+4]
  000b0	7d 1d		 jge	 SHORT $LN7@Assemble

; 70   : 			{
; 71   : 				indiv[m] = terms[termToken].list[b];

  000b2	0f b6 4d ff	 movzx	 ecx, BYTE PTR _termToken$[ebp]
  000b6	8b 55 e8	 mov	 edx, DWORD PTR _terms$[ebp]
  000b9	8b 04 ca	 mov	 eax, DWORD PTR [edx+ecx*8]
  000bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _indiv
  000c2	03 4d f8	 add	 ecx, DWORD PTR _m$[ebp]
  000c5	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  000c8	8a 04 10	 mov	 al, BYTE PTR [eax+edx]
  000cb	88 01		 mov	 BYTE PTR [ecx], al

; 72   : 			}

  000cd	eb c1		 jmp	 SHORT $LN5@Assemble
$LN7@Assemble:

; 73   : 		}
; 74   : 	}

  000cf	e9 5b ff ff ff	 jmp	 $LN9@Assemble
$LN8@Assemble:

; 75   : 	for (j = 0; j < footerLen; j++,m++)

  000d4	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000db	eb 12		 jmp	 SHORT $LN3@Assemble
$LN2@Assemble:
  000dd	8b 4d ec	 mov	 ecx, DWORD PTR _j$[ebp]
  000e0	83 c1 01	 add	 ecx, 1
  000e3	89 4d ec	 mov	 DWORD PTR _j$[ebp], ecx
  000e6	8b 55 f8	 mov	 edx, DWORD PTR _m$[ebp]
  000e9	83 c2 01	 add	 edx, 1
  000ec	89 55 f8	 mov	 DWORD PTR _m$[ebp], edx
$LN3@Assemble:
  000ef	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _footerLen
  000f6	39 45 ec	 cmp	 DWORD PTR _j$[ebp], eax
  000f9	7d 18		 jge	 SHORT $LN11@Assemble

; 76   : 	{
; 77   : 		indiv[m] = footer[j];

  000fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _indiv
  00101	03 4d f8	 add	 ecx, DWORD PTR _m$[ebp]
  00104	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _footer
  0010a	03 55 ec	 add	 edx, DWORD PTR _j$[ebp]
  0010d	8a 02		 mov	 al, BYTE PTR [edx]
  0010f	88 01		 mov	 BYTE PTR [ecx], al

; 78   : 	}

  00111	eb ca		 jmp	 SHORT $LN2@Assemble
$LN11@Assemble:

; 79   : }

  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c3		 ret	 0
_Assemble ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\indiv.c
_TEXT	SEGMENT
tv178 = -24						; size = 8
tv169 = -16						; size = 8
_hits$ = -8						; size = 4
_c$ = -4						; size = 4
_cases$ = 8						; size = 4
_nSamples$ = 12						; size = 4
__tkIndiv$ = 16						; size = 4
_EvalIndivHitRate PROC

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 103  : 	int c;
; 104  : 	int hits = 0;

  00007	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hits$[ebp], 0

; 105  : 
; 106  : 	_tkIndiv->error = 0;

  0000e	8b 45 10	 mov	 eax, DWORD PTR __tkIndiv$[ebp]
  00011	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@0000000000000000
  00019	f2 0f 11 40 18	 movsd	 QWORD PTR [eax+24], xmm0

; 107  : 	for (c = 0; c < nSamples; c++)

  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _c$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN7@EvalIndivH
$LN6@EvalIndivH:
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  0002a	83 c1 01	 add	 ecx, 1
  0002d	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
$LN7@EvalIndivH:
  00030	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  00033	3b 55 0c	 cmp	 edx, DWORD PTR _nSamples$[ebp]
  00036	0f 8d f3 00 00
	00		 jge	 $LN5@EvalIndivH

; 108  : 	{
; 109  : 		InitCase(c, cases);

  0003c	8b 45 08	 mov	 eax, DWORD PTR _cases$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _InitCase
  00049	83 c4 08	 add	 esp, 8

; 110  : 		RunCase(caseVector);

  0004c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _caseVector
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 _RunCase
  00058	83 c4 04	 add	 esp, 4

; 111  : 		if (cases[c * dataRowDim + nVars])

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  0005e	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _dataRowDim
  00065	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nVars
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _cases$[ebp]
  0006e	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [ecx+eax*4]
  00073	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0007a	9f		 lahf
  0007b	f6 c4 44	 test	 ah, 68			; 00000044H
  0007e	7b 28		 jnp	 SHORT $LN4@EvalIndivH

; 112  : 		{
; 113  : 			if (caseVector[0] >= 0.5) hits++;

  00080	ba 04 00 00 00	 mov	 edx, 4
  00085	6b c2 00	 imul	 eax, edx, 0
  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _caseVector
  0008e	f3 0f 5a 04 01	 cvtss2sd xmm0, DWORD PTR [ecx+eax]
  00093	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3fe0000000000000
  0009b	72 09		 jb	 SHORT $LN3@EvalIndivH
  0009d	8b 55 f8	 mov	 edx, DWORD PTR _hits$[ebp]
  000a0	83 c2 01	 add	 edx, 1
  000a3	89 55 f8	 mov	 DWORD PTR _hits$[ebp], edx
$LN3@EvalIndivH:

; 114  : 		}
; 115  : 		else

  000a6	eb 2a		 jmp	 SHORT $LN1@EvalIndivH
$LN4@EvalIndivH:

; 116  : 		{
; 117  : 			if (caseVector[0] < 0.5) hits++;

  000a8	b8 04 00 00 00	 mov	 eax, 4
  000ad	6b c8 00	 imul	 ecx, eax, 0
  000b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _caseVector
  000b6	f3 0f 5a 04 0a	 cvtss2sd xmm0, DWORD PTR [edx+ecx]
  000bb	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3fe0000000000000
  000c3	66 0f 2f c8	 comisd	 xmm1, xmm0
  000c7	76 09		 jbe	 SHORT $LN1@EvalIndivH
  000c9	8b 45 f8	 mov	 eax, DWORD PTR _hits$[ebp]
  000cc	83 c0 01	 add	 eax, 1
  000cf	89 45 f8	 mov	 DWORD PTR _hits$[ebp], eax
$LN1@EvalIndivH:

; 118  : 		}
; 119  : 		_tkIndiv->error += fabs(caseVector[0] - 
; 120  : 			                    cases[c * dataRowDim + nVars]);

  000d2	b9 04 00 00 00	 mov	 ecx, 4
  000d7	6b d1 00	 imul	 edx, ecx, 0
  000da	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  000dd	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _dataRowDim
  000e4	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nVars
  000ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _caseVector
  000f0	8b 75 08	 mov	 esi, DWORD PTR _cases$[ebp]
  000f3	f3 0f 10 04 11	 movss	 xmm0, DWORD PTR [ecx+edx]
  000f8	f3 0f 5c 04 86	 subss	 xmm0, DWORD PTR [esi+eax*4]
  000fd	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00101	83 ec 08	 sub	 esp, 8
  00104	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fabs
  0010f	83 c4 08	 add	 esp, 8
  00112	dd 5d f0	 fstp	 QWORD PTR tv169[ebp]
  00115	8b 55 10	 mov	 edx, DWORD PTR __tkIndiv$[ebp]
  00118	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR tv169[ebp]
  0011d	f2 0f 58 42 18	 addsd	 xmm0, QWORD PTR [edx+24]
  00122	8b 45 10	 mov	 eax, DWORD PTR __tkIndiv$[ebp]
  00125	f2 0f 11 40 18	 movsd	 QWORD PTR [eax+24], xmm0

; 121  : 	}

  0012a	e9 f8 fe ff ff	 jmp	 $LN6@EvalIndivH
$LN5@EvalIndivH:

; 122  : 	//nEvaluations++;
; 123  : 	_tkIndiv->error /= nSamples;

  0012f	f2 0f 2a 45 0c	 cvtsi2sd xmm0, DWORD PTR _nSamples$[ebp]
  00134	8b 4d 10	 mov	 ecx, DWORD PTR __tkIndiv$[ebp]
  00137	f2 0f 10 49 18	 movsd	 xmm1, QWORD PTR [ecx+24]
  0013c	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00140	8b 55 10	 mov	 edx, DWORD PTR __tkIndiv$[ebp]
  00143	f2 0f 11 4a 18	 movsd	 QWORD PTR [edx+24], xmm1

; 124  : 
; 125  : 	return (1 - ((double)hits / nSamples));

  00148	f2 0f 2a 45 f8	 cvtsi2sd xmm0, DWORD PTR _hits$[ebp]
  0014d	f2 0f 2a 4d 0c	 cvtsi2sd xmm1, DWORD PTR _nSamples$[ebp]
  00152	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00156	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  0015e	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00162	f2 0f 11 4d e8	 movsd	 QWORD PTR tv178[ebp], xmm1
  00167	dd 45 e8	 fld	 QWORD PTR tv178[ebp]

; 126  : }

  0016a	5e		 pop	 esi
  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c3		 ret	 0
_EvalIndivHitRate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\indiv.c
_TEXT	SEGMENT
tv135 = -20						; size = 8
tv138 = -12						; size = 4
_sError$ = -8						; size = 4
_c$ = -4						; size = 4
_cases$ = 8						; size = 4
_nSamples$ = 12						; size = 4
__tkIndiv$ = 16						; size = 4
_EvalIndiv PROC

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi

; 83   : 	register int c;
; 84   : 	static int idx;
; 85   : 	float sError = 0.0;

  00007	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@00000000
  0000f	f3 0f 11 45 f8	 movss	 DWORD PTR _sError$[ebp], xmm0

; 86   : 
; 87   : 	for (c = 0; c < nSamples; c++)

  00014	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _c$[ebp], 0
  0001b	eb 09		 jmp	 SHORT $LN3@EvalIndiv
$LN2@EvalIndiv:
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00020	83 c0 01	 add	 eax, 1
  00023	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax
$LN3@EvalIndiv:
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  00029	3b 4d 0c	 cmp	 ecx, DWORD PTR _nSamples$[ebp]
  0002c	0f 8d 85 00 00
	00		 jge	 $LN1@EvalIndiv

; 88   : 	{
; 89   : 		InitCase(c, cases);

  00032	8b 55 08	 mov	 edx, DWORD PTR _cases$[ebp]
  00035	52		 push	 edx
  00036	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _InitCase
  0003f	83 c4 08	 add	 esp, 8

; 90   : 		RunCase(caseVector);

  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _caseVector
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 _RunCase
  0004e	83 c4 04	 add	 esp, 4

; 91   : 		idx = c * dataRowDim + nVars;

  00051	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  00054	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR _dataRowDim
  0005b	03 15 00 00 00
	00		 add	 edx, DWORD PTR _nVars
  00061	89 15 00 00 00
	00		 mov	 DWORD PTR ?idx@?1??EvalIndiv@@9@9, edx

; 92   : 		sError +=  fabs(caseVector[0] - cases[idx]); //MAE

  00067	b8 04 00 00 00	 mov	 eax, 4
  0006c	6b c8 00	 imul	 ecx, eax, 0
  0006f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _caseVector
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR ?idx@?1??EvalIndiv@@9@9
  0007a	8b 75 08	 mov	 esi, DWORD PTR _cases$[ebp]
  0007d	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00082	f3 0f 5c 04 86	 subss	 xmm0, DWORD PTR [esi+eax*4]
  00087	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0008b	83 ec 08	 sub	 esp, 8
  0008e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fabs
  00099	83 c4 08	 add	 esp, 8
  0009c	dd 5d ec	 fstp	 QWORD PTR tv135[ebp]
  0009f	f3 0f 5a 45 f8	 cvtss2sd xmm0, DWORD PTR _sError$[ebp]
  000a4	f2 0f 58 45 ec	 addsd	 xmm0, QWORD PTR tv135[ebp]
  000a9	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  000ad	f3 0f 11 45 f8	 movss	 DWORD PTR _sError$[ebp], xmm0

; 93   : 		//sError +=  fabs((caseVector[0] - cases[idx]) / cases[idx]); //MAPE
; 94   :         //sError +=  fabs(DiscipulusAssemblerFunction(caseVector) - cases[c * dataRowDim + nVars]);
; 95   :         //sError +=  pow(caseVector[0] - cases[c * dataRowDim + nVars], 2); //MSE
; 96   : 	}

  000b2	e9 66 ff ff ff	 jmp	 $LN2@EvalIndiv
$LN1@EvalIndiv:

; 97   : 
; 98   : 	return (sError / nSamples);

  000b7	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _nSamples$[ebp]
  000bc	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _sError$[ebp]
  000c1	f3 0f 5e c8	 divss	 xmm1, xmm0
  000c5	f3 0f 11 4d f4	 movss	 DWORD PTR tv138[ebp], xmm1
  000ca	d9 45 f4	 fld	 DWORD PTR tv138[ebp]

; 99   : }

  000cd	5e		 pop	 esi
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_EvalIndiv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\indiv.c
_TEXT	SEGMENT
_indivLen$ = -8						; size = 4
_i$ = -4						; size = 4
_dstTkIndiv$ = 8					; size = 4
_srcTkIndiv$ = 12					; size = 4
_CopyTkIndiv PROC

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 131  : 	register int i;
; 132  : 	register int indivLen = qIndivLen * 2;

  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR _qIndivLen
  0000c	d1 e0		 shl	 eax, 1
  0000e	89 45 f8	 mov	 DWORD PTR _indivLen$[ebp], eax

; 133  : 
; 134  : 	for (i = 0; i < indivLen; i++)

  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00018	eb 09		 jmp	 SHORT $LN3@CopyTkIndi
$LN2@CopyTkIndi:
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001d	83 c1 01	 add	 ecx, 1
  00020	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN3@CopyTkIndi:
  00023	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00026	3b 55 f8	 cmp	 edx, DWORD PTR _indivLen$[ebp]
  00029	7d 18		 jge	 SHORT $LN1@CopyTkIndi

; 135  : 	{
; 136  : 		dstTkIndiv->genome[i] = srcTkIndiv->genome[i];

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _srcTkIndiv$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	8b 55 08	 mov	 edx, DWORD PTR _dstTkIndiv$[ebp]
  00033	8b 02		 mov	 eax, DWORD PTR [edx]
  00035	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00038	8b 75 fc	 mov	 esi, DWORD PTR _i$[ebp]
  0003b	8a 0c 31	 mov	 cl, BYTE PTR [ecx+esi]
  0003e	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 137  : 	}

  00041	eb d7		 jmp	 SHORT $LN2@CopyTkIndi
$LN1@CopyTkIndi:

; 138  : 	dstTkIndiv->fitness = srcTkIndiv->fitness;

  00043	8b 55 08	 mov	 edx, DWORD PTR _dstTkIndiv$[ebp]
  00046	8b 45 0c	 mov	 eax, DWORD PTR _srcTkIndiv$[ebp]
  00049	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  0004e	f2 0f 11 42 08	 movsd	 QWORD PTR [edx+8], xmm0

; 139  : 	dstTkIndiv->validFitness = srcTkIndiv->validFitness;

  00053	8b 4d 08	 mov	 ecx, DWORD PTR _dstTkIndiv$[ebp]
  00056	8b 55 0c	 mov	 edx, DWORD PTR _srcTkIndiv$[ebp]
  00059	f2 0f 10 42 10	 movsd	 xmm0, QWORD PTR [edx+16]
  0005e	f2 0f 11 41 10	 movsd	 QWORD PTR [ecx+16], xmm0

; 140  : 	dstTkIndiv->error = srcTkIndiv->error;

  00063	8b 45 08	 mov	 eax, DWORD PTR _dstTkIndiv$[ebp]
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _srcTkIndiv$[ebp]
  00069	f2 0f 10 41 18	 movsd	 xmm0, QWORD PTR [ecx+24]
  0006e	f2 0f 11 40 18	 movsd	 QWORD PTR [eax+24], xmm0

; 141  : 	dstTkIndiv->length = srcTkIndiv->length;

  00073	8b 55 08	 mov	 edx, DWORD PTR _dstTkIndiv$[ebp]
  00076	8b 45 0c	 mov	 eax, DWORD PTR _srcTkIndiv$[ebp]
  00079	8a 48 20	 mov	 cl, BYTE PTR [eax+32]
  0007c	88 4a 20	 mov	 BYTE PTR [edx+32], cl

; 142  : 	dstTkIndiv->shortest = srcTkIndiv->shortest;

  0007f	8b 55 08	 mov	 edx, DWORD PTR _dstTkIndiv$[ebp]
  00082	8b 45 0c	 mov	 eax, DWORD PTR _srcTkIndiv$[ebp]
  00085	8a 48 21	 mov	 cl, BYTE PTR [eax+33]
  00088	88 4a 21	 mov	 BYTE PTR [edx+33], cl

; 143  : }

  0008b	5e		 pop	 esi
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
_CopyTkIndiv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\indiv.c
_TEXT	SEGMENT
_i$ = -1						; size = 1
_InitIndiv PROC

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 10   : 	register byte i;
; 11   : 
; 12   : 	indiv = malloc(indivLen * sizeof(byte));

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _indivLen
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00011	83 c4 04	 add	 esp, 4
  00014	a3 00 00 00 00	 mov	 DWORD PTR _indiv, eax

; 13   : 
; 14   : 	for (i = 0; i < headerLen; i++)

  00019	c6 45 ff 00	 mov	 BYTE PTR _i$[ebp], 0
  0001d	eb 09		 jmp	 SHORT $LN3@InitIndiv
$LN2@InitIndiv:
  0001f	8a 4d ff	 mov	 cl, BYTE PTR _i$[ebp]
  00022	80 c1 01	 add	 cl, 1
  00025	88 4d ff	 mov	 BYTE PTR _i$[ebp], cl
$LN3@InitIndiv:
  00028	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  0002c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _headerLen
  00033	3b d0		 cmp	 edx, eax
  00035	7d 1b		 jge	 SHORT $LN4@InitIndiv

; 15   : 	{
; 16   : 		indiv[i] = header[i];

  00037	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$[ebp]
  0003b	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR _indiv
  00044	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _header
  0004a	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  0004d	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 17   : 	}

  00050	eb cd		 jmp	 SHORT $LN2@InitIndiv
$LN4@InitIndiv:

; 18   : }

  00052	5e		 pop	 esi
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_InitIndiv ENDP
_TEXT	ENDS
END
