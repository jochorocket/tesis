; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	D:\JOCHO\sanpa\seminario de tesis\QILGP\QILGP\qIndiv.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_LGate2QTokenNoNorm
PUBLIC	_ResetQGene
PUBLIC	_InitQLinGene
PUBLIC	_ResetQToken
PUBLIC	_ResetFuncQToken
PUBLIC	_ObserveQToken
PUBLIC	_InitFuncQToken
PUBLIC	_InitSintaticTable
PUBLIC	_InitQIndiv
PUBLIC	_LGateNoNorm
PUBLIC	_ObserveQIndiv
PUBLIC	_ResetQIndiv
PUBLIC	_InitQToken
	ALIGN	8

?_qNopProb@?1??ResetFuncQToken@@9@9 DQ 01H DUP (?)	; `ResetFuncQToken'::`2'::_qNopProb
?randNum@?1??ObserveQToken@@9@9 DQ 01H DUP (?)		; `ObserveQToken'::`2'::randNum
?inc@?1??LGate2QTokenNoNorm@@9@9 DQ 01H DUP (?)		; `LGate2QTokenNoNorm'::`2'::inc
?probStep@?1??ResetQToken@@9@9 DQ 01H DUP (?)		; `ResetQToken'::`2'::probStep
?lastTkIdx@?1??LGate2QTokenNoNorm@@9@9 DD 01H DUP (?)	; `LGate2QTokenNoNorm'::`2'::lastTkIdx
_BSS	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\qindiv.c
_TEXT	SEGMENT
_probStep$ = -20					; size = 8
_qT$ = -12						; size = 8
_i$ = -1						; size = 1
_cardinality$ = 8					; size = 1
_InitQToken PROC

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 42   : 	qToken qT;
; 43   : 	register byte i;
; 44   : 	double probStep; // Probabilities step
; 45   : 
; 46   : 	qT.alphas = malloc(cardinality * sizeof(double));

  00006	0f b6 45 08	 movzx	 eax, BYTE PTR _cardinality$[ebp]
  0000a	c1 e0 03	 shl	 eax, 3
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 f8	 mov	 DWORD PTR _qT$[ebp+4], eax

; 47   : 	qT.cardinality = cardinality;

  0001a	8a 4d 08	 mov	 cl, BYTE PTR _cardinality$[ebp]
  0001d	88 4d f4	 mov	 BYTE PTR _qT$[ebp], cl

; 48   : 
; 49   : 	if (cardinality == 0)

  00020	0f b6 55 08	 movzx	 edx, BYTE PTR _cardinality$[ebp]
  00024	85 d2		 test	 edx, edx
  00026	75 12		 jne	 SHORT $LN13@InitQToken

; 50   : 	{
; 51   : 		probStep = 1.0;

  00028	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00030	f2 0f 11 45 ec	 movsd	 QWORD PTR _probStep$[ebp], xmm0
  00035	e9 f4 00 00 00	 jmp	 $LN4@InitQToken
$LN13@InitQToken:

; 52   : 	}
; 53   : 	else if (cardinality == nVars + nConsts)

  0003a	0f b6 45 08	 movzx	 eax, BYTE PTR _cardinality$[ebp]
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nVars
  00044	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _nConsts
  0004a	3b c1		 cmp	 eax, ecx
  0004c	0f 85 c3 00 00
	00		 jne	 $LN11@InitQToken

; 54   : 	{
; 55   : 		probStep = 0.5 / nVars;

  00052	f2 0f 2a 05 00
	00 00 00	 cvtsi2sd xmm0, DWORD PTR _nVars
  0005a	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3fe0000000000000
  00062	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00066	f2 0f 11 4d ec	 movsd	 QWORD PTR _probStep$[ebp], xmm1

; 56   : 		qT.alphas[0] = probStep;

  0006b	ba 08 00 00 00	 mov	 edx, 8
  00070	6b c2 00	 imul	 eax, edx, 0
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _qT$[ebp+4]
  00076	f2 0f 10 45 ec	 movsd	 xmm0, QWORD PTR _probStep$[ebp]
  0007b	f2 0f 11 04 01	 movsd	 QWORD PTR [ecx+eax], xmm0

; 57   : 		for (i = 1; i < nVars; i++)

  00080	c6 45 ff 01	 mov	 BYTE PTR _i$[ebp], 1
  00084	eb 09		 jmp	 SHORT $LN10@InitQToken
$LN9@InitQToken:
  00086	8a 55 ff	 mov	 dl, BYTE PTR _i$[ebp]
  00089	80 c2 01	 add	 dl, 1
  0008c	88 55 ff	 mov	 BYTE PTR _i$[ebp], dl
$LN10@InitQToken:
  0008f	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  00093	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nVars
  00099	7d 20		 jge	 SHORT $LN8@InitQToken

; 58   : 		{
; 59   : 			qT.alphas[i] = qT.alphas[i - 1] + probStep;

  0009b	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$[ebp]
  0009f	8b 55 f8	 mov	 edx, DWORD PTR _qT$[ebp+4]
  000a2	f2 0f 10 44 ca
	f8		 movsd	 xmm0, QWORD PTR [edx+ecx*8-8]
  000a8	f2 0f 58 45 ec	 addsd	 xmm0, QWORD PTR _probStep$[ebp]
  000ad	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  000b1	8b 4d f8	 mov	 ecx, DWORD PTR _qT$[ebp+4]
  000b4	f2 0f 11 04 c1	 movsd	 QWORD PTR [ecx+eax*8], xmm0

; 60   : 		}

  000b9	eb cb		 jmp	 SHORT $LN9@InitQToken
$LN8@InitQToken:

; 61   : 		probStep = 0.5 / nConsts;

  000bb	f2 0f 2a 05 00
	00 00 00	 cvtsi2sd xmm0, DWORD PTR _nConsts
  000c3	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3fe0000000000000
  000cb	f2 0f 5e c8	 divsd	 xmm1, xmm0
  000cf	f2 0f 11 4d ec	 movsd	 QWORD PTR _probStep$[ebp], xmm1

; 62   : 		for (; i < cardinality; i++)

  000d4	eb 09		 jmp	 SHORT $LN7@InitQToken
$LN6@InitQToken:
  000d6	8a 55 ff	 mov	 dl, BYTE PTR _i$[ebp]
  000d9	80 c2 01	 add	 dl, 1
  000dc	88 55 ff	 mov	 BYTE PTR _i$[ebp], dl
$LN7@InitQToken:
  000df	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  000e3	0f b6 4d 08	 movzx	 ecx, BYTE PTR _cardinality$[ebp]
  000e7	3b c1		 cmp	 eax, ecx
  000e9	7d 20		 jge	 SHORT $LN5@InitQToken

; 63   : 		{
; 64   : 			qT.alphas[i] = qT.alphas[i - 1] + probStep;

  000eb	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  000ef	8b 45 f8	 mov	 eax, DWORD PTR _qT$[ebp+4]
  000f2	f2 0f 10 44 d0
	f8		 movsd	 xmm0, QWORD PTR [eax+edx*8-8]
  000f8	f2 0f 58 45 ec	 addsd	 xmm0, QWORD PTR _probStep$[ebp]
  000fd	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$[ebp]
  00101	8b 55 f8	 mov	 edx, DWORD PTR _qT$[ebp+4]
  00104	f2 0f 11 04 ca	 movsd	 QWORD PTR [edx+ecx*8], xmm0

; 65   : 		}

  00109	eb cb		 jmp	 SHORT $LN6@InitQToken
$LN5@InitQToken:

; 66   : 		return qT;

  0010b	8b 45 f4	 mov	 eax, DWORD PTR _qT$[ebp]
  0010e	8b 55 f8	 mov	 edx, DWORD PTR _qT$[ebp+4]
  00111	eb 71		 jmp	 SHORT $LN14@InitQToken

; 67   : 	}
; 68   : 	else

  00113	eb 19		 jmp	 SHORT $LN4@InitQToken
$LN11@InitQToken:

; 69   : 	{
; 70   : 		probStep = (1.0 / cardinality);

  00115	0f b6 45 08	 movzx	 eax, BYTE PTR _cardinality$[ebp]
  00119	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  0011d	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00125	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00129	f2 0f 11 4d ec	 movsd	 QWORD PTR _probStep$[ebp], xmm1
$LN4@InitQToken:

; 71   : 	}
; 72   : 	qT.alphas[0] = probStep;

  0012e	b9 08 00 00 00	 mov	 ecx, 8
  00133	6b d1 00	 imul	 edx, ecx, 0
  00136	8b 45 f8	 mov	 eax, DWORD PTR _qT$[ebp+4]
  00139	f2 0f 10 45 ec	 movsd	 xmm0, QWORD PTR _probStep$[ebp]
  0013e	f2 0f 11 04 10	 movsd	 QWORD PTR [eax+edx], xmm0

; 73   : 	for (i = 1; i < cardinality; i++)

  00143	c6 45 ff 01	 mov	 BYTE PTR _i$[ebp], 1
  00147	eb 09		 jmp	 SHORT $LN3@InitQToken
$LN2@InitQToken:
  00149	8a 4d ff	 mov	 cl, BYTE PTR _i$[ebp]
  0014c	80 c1 01	 add	 cl, 1
  0014f	88 4d ff	 mov	 BYTE PTR _i$[ebp], cl
$LN3@InitQToken:
  00152	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  00156	0f b6 45 08	 movzx	 eax, BYTE PTR _cardinality$[ebp]
  0015a	3b d0		 cmp	 edx, eax
  0015c	7d 20		 jge	 SHORT $LN1@InitQToken

; 74   : 	{
; 75   : 		qT.alphas[i] = qT.alphas[i - 1] + probStep;

  0015e	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$[ebp]
  00162	8b 55 f8	 mov	 edx, DWORD PTR _qT$[ebp+4]
  00165	f2 0f 10 44 ca
	f8		 movsd	 xmm0, QWORD PTR [edx+ecx*8-8]
  0016b	f2 0f 58 45 ec	 addsd	 xmm0, QWORD PTR _probStep$[ebp]
  00170	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  00174	8b 4d f8	 mov	 ecx, DWORD PTR _qT$[ebp+4]
  00177	f2 0f 11 04 c1	 movsd	 QWORD PTR [ecx+eax*8], xmm0

; 76   : 	}

  0017c	eb cb		 jmp	 SHORT $LN2@InitQToken
$LN1@InitQToken:

; 77   : 	
; 78   : 	return qT;

  0017e	8b 45 f4	 mov	 eax, DWORD PTR _qT$[ebp]
  00181	8b 55 f8	 mov	 edx, DWORD PTR _qT$[ebp+4]
$LN14@InitQToken:

; 79   : } 

  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c3		 ret	 0
_InitQToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\qindiv.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_qIndiv$ = 8						; size = 4
_ResetQIndiv PROC

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 236  :     register int i;
; 237  : 
; 238  : 	for (i = 0; i < qIndivLen; i++)

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000b	eb 09		 jmp	 SHORT $LN3@ResetQIndi
$LN2@ResetQIndi:
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00010	83 c0 01	 add	 eax, 1
  00013	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@ResetQIndi:
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00019	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _qIndivLen
  0001f	7d 22		 jge	 SHORT $LN1@ResetQIndi

; 239  : 	{
; 240  :         ResetQGene(&qIndiv[i], qNopProb);

  00021	83 ec 08	 sub	 esp, 8
  00024	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _qNopProb
  0002c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00031	6b 55 fc 0c	 imul	 edx, DWORD PTR _i$[ebp], 12
  00035	03 55 08	 add	 edx, DWORD PTR _qIndiv$[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _ResetQGene
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 241  : 	}

  00041	eb ca		 jmp	 SHORT $LN2@ResetQIndi
$LN1@ResetQIndi:

; 242  : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_ResetQIndiv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\qindiv.c
_TEXT	SEGMENT
_qIdx$ = -28						; size = 4
_terms$ = -24						; size = 4
_j$ = -20						; size = 4
_b$ = -16						; size = 4
_m$ = -12						; size = 4
_i$ = -8						; size = 4
_funcToken$ = -2					; size = 1
_termToken$ = -1					; size = 1
_qLinIndiv$ = 8						; size = 4
__tkIndiv$ = 12						; size = 4
_ObserveQIndiv PROC

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 292  : 	int i, j, b, qIdx;
; 293  : 	int m;
; 294  : 	byte funcToken;
; 295  : 	byte termToken = 0;

  00006	c6 45 ff 00	 mov	 BYTE PTR _termToken$[ebp], 0

; 296  : 	byteList *terms;
; 297  : 	
; 298  : 	_tkIndiv->length = 0;

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __tkIndiv$[ebp]
  0000d	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0

; 299  : 
; 300  : 	m = headerLen;

  00011	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _headerLen
  00018	89 4d f4	 mov	 DWORD PTR _m$[ebp], ecx

; 301  : 	for (i = 0; i < qIndivLen; i++)

  0001b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00022	eb 09		 jmp	 SHORT $LN14@ObserveQIn
$LN13@ObserveQIn:
  00024	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00027	83 c2 01	 add	 edx, 1
  0002a	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN14@ObserveQIn:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00030	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _qIndivLen
  00036	0f 8d 1a 01 00
	00		 jge	 $LN12@ObserveQIn

; 302  : 	{
; 303  : 		funcToken = ObserveQToken(&qLinIndiv[i].funcQT);

  0003c	6b 4d f8 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  00040	03 4d 08	 add	 ecx, DWORD PTR _qLinIndiv$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _ObserveQToken
  00049	83 c4 04	 add	 esp, 4
  0004c	88 45 fe	 mov	 BYTE PTR _funcToken$[ebp], al

; 304  : 		qIdx = i * 2;

  0004f	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00052	d1 e2		 shl	 edx, 1
  00054	89 55 e4	 mov	 DWORD PTR _qIdx$[ebp], edx

; 305  : 		if (funcToken > 0)

  00057	0f b6 45 fe	 movzx	 eax, BYTE PTR _funcToken$[ebp]
  0005b	85 c0		 test	 eax, eax
  0005d	0f 8e e0 00 00
	00		 jle	 $LN11@ObserveQIn

; 306  : 		{
; 307  : 			_tkIndiv->length++;

  00063	8b 4d 0c	 mov	 ecx, DWORD PTR __tkIndiv$[ebp]
  00066	8a 51 20	 mov	 dl, BYTE PTR [ecx+32]
  00069	80 c2 01	 add	 dl, 1
  0006c	8b 45 0c	 mov	 eax, DWORD PTR __tkIndiv$[ebp]
  0006f	88 50 20	 mov	 BYTE PTR [eax+32], dl

; 308  : 			if (!typedTerms)

  00072	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _typedTerms
  00079	85 c9		 test	 ecx, ecx
  0007b	75 20		 jne	 SHORT $LN10@ObserveQIn

; 309  : 			{
; 310  : 			    termToken = ObserveQToken(&qLinIndiv[i].termQTs[funcToken]);

  0007d	6b 55 f8 0c	 imul	 edx, DWORD PTR _i$[ebp], 12
  00081	0f b6 45 fe	 movzx	 eax, BYTE PTR _funcToken$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _qLinIndiv$[ebp]
  00088	8b 54 11 08	 mov	 edx, DWORD PTR [ecx+edx+8]
  0008c	8d 04 c2	 lea	 eax, DWORD PTR [edx+eax*8]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _ObserveQToken
  00095	83 c4 04	 add	 esp, 4
  00098	88 45 ff	 mov	 BYTE PTR _termToken$[ebp], al

; 311  : 			}
; 312  : 			else

  0009b	eb 3f		 jmp	 SHORT $LN9@ObserveQIn
$LN10@ObserveQIn:

; 313  : 			{
; 314  : 				if (termIdxs[funcToken] == 0)

  0009d	0f b6 4d fe	 movzx	 ecx, BYTE PTR _funcToken$[ebp]
  000a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _termIdxs
  000a7	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000ab	85 c0		 test	 eax, eax
  000ad	75 06		 jne	 SHORT $LN8@ObserveQIn

; 315  : 				{
; 316  : 					termToken = 0;

  000af	c6 45 ff 00	 mov	 BYTE PTR _termToken$[ebp], 0

; 317  : 				}
; 318  : 				else

  000b3	eb 27		 jmp	 SHORT $LN9@ObserveQIn
$LN8@ObserveQIn:

; 319  : 				{
; 320  : 					termToken = ObserveQToken(&qLinIndiv[i].termQTs[termIdxs[funcToken]]);	

  000b5	6b 4d f8 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  000b9	0f b6 55 fe	 movzx	 edx, BYTE PTR _funcToken$[ebp]
  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _termIdxs
  000c2	0f b6 14 10	 movzx	 edx, BYTE PTR [eax+edx]
  000c6	8b 45 08	 mov	 eax, DWORD PTR _qLinIndiv$[ebp]
  000c9	8b 4c 08 08	 mov	 ecx, DWORD PTR [eax+ecx+8]
  000cd	8d 14 d1	 lea	 edx, DWORD PTR [ecx+edx*8]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 _ObserveQToken
  000d6	83 c4 04	 add	 esp, 4
  000d9	88 45 ff	 mov	 BYTE PTR _termToken$[ebp], al
$LN9@ObserveQIn:

; 321  : 				}
; 322  : 			}
; 323  : 			terms = sintTable[funcToken];

  000dc	0f b6 45 fe	 movzx	 eax, BYTE PTR _funcToken$[ebp]
  000e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sintTable
  000e6	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000e9	89 55 e8	 mov	 DWORD PTR _terms$[ebp], edx

; 324  : 			for (b = 0; b < terms[termToken].length; b++, m++)

  000ec	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _b$[ebp], 0
  000f3	eb 12		 jmp	 SHORT $LN6@ObserveQIn
$LN5@ObserveQIn:
  000f5	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  000f8	83 c0 01	 add	 eax, 1
  000fb	89 45 f0	 mov	 DWORD PTR _b$[ebp], eax
  000fe	8b 4d f4	 mov	 ecx, DWORD PTR _m$[ebp]
  00101	83 c1 01	 add	 ecx, 1
  00104	89 4d f4	 mov	 DWORD PTR _m$[ebp], ecx
$LN6@ObserveQIn:
  00107	0f b6 55 ff	 movzx	 edx, BYTE PTR _termToken$[ebp]
  0010b	8b 45 e8	 mov	 eax, DWORD PTR _terms$[ebp]
  0010e	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  00111	3b 4c d0 04	 cmp	 ecx, DWORD PTR [eax+edx*8+4]
  00115	7d 1d		 jge	 SHORT $LN4@ObserveQIn

; 325  : 			{
; 326  : 				indiv[m] = terms[termToken].list[b];

  00117	0f b6 55 ff	 movzx	 edx, BYTE PTR _termToken$[ebp]
  0011b	8b 45 e8	 mov	 eax, DWORD PTR _terms$[ebp]
  0011e	8b 0c d0	 mov	 ecx, DWORD PTR [eax+edx*8]
  00121	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _indiv
  00127	03 55 f4	 add	 edx, DWORD PTR _m$[ebp]
  0012a	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  0012d	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  00130	88 0a		 mov	 BYTE PTR [edx], cl

; 327  : 			}

  00132	eb c1		 jmp	 SHORT $LN5@ObserveQIn
$LN4@ObserveQIn:

; 328  : 			*(_tkIndiv->genome + qIdx + 1) = termToken;

  00134	8b 55 0c	 mov	 edx, DWORD PTR __tkIndiv$[ebp]
  00137	8b 02		 mov	 eax, DWORD PTR [edx]
  00139	8b 4d e4	 mov	 ecx, DWORD PTR _qIdx$[ebp]
  0013c	8a 55 ff	 mov	 dl, BYTE PTR _termToken$[ebp]
  0013f	88 54 08 01	 mov	 BYTE PTR [eax+ecx+1], dl
$LN11@ObserveQIn:

; 329  : 		}
; 330  : 		//qIdx = i * 2;
; 331  : 		*(_tkIndiv->genome + qIdx) = funcToken;

  00143	8b 45 0c	 mov	 eax, DWORD PTR __tkIndiv$[ebp]
  00146	8b 08		 mov	 ecx, DWORD PTR [eax]
  00148	8b 55 e4	 mov	 edx, DWORD PTR _qIdx$[ebp]
  0014b	8a 45 fe	 mov	 al, BYTE PTR _funcToken$[ebp]
  0014e	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 332  : 		//*(_tkIndiv->genome + qIdx + 1) = termToken;
; 333  : 	}

  00151	e9 ce fe ff ff	 jmp	 $LN13@ObserveQIn
$LN12@ObserveQIn:

; 334  : 	for (j = 0; j < footerLen; j++,m++)

  00156	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0015d	eb 12		 jmp	 SHORT $LN3@ObserveQIn
$LN2@ObserveQIn:
  0015f	8b 4d ec	 mov	 ecx, DWORD PTR _j$[ebp]
  00162	83 c1 01	 add	 ecx, 1
  00165	89 4d ec	 mov	 DWORD PTR _j$[ebp], ecx
  00168	8b 55 f4	 mov	 edx, DWORD PTR _m$[ebp]
  0016b	83 c2 01	 add	 edx, 1
  0016e	89 55 f4	 mov	 DWORD PTR _m$[ebp], edx
$LN3@ObserveQIn:
  00171	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _footerLen
  00178	39 45 ec	 cmp	 DWORD PTR _j$[ebp], eax
  0017b	7d 18		 jge	 SHORT $LN15@ObserveQIn

; 335  : 	{
; 336  : 		indiv[m] = footer[j];

  0017d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _indiv
  00183	03 4d f4	 add	 ecx, DWORD PTR _m$[ebp]
  00186	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _footer
  0018c	03 55 ec	 add	 edx, DWORD PTR _j$[ebp]
  0018f	8a 02		 mov	 al, BYTE PTR [edx]
  00191	88 01		 mov	 BYTE PTR [ecx], al

; 337  : 	}

  00193	eb ca		 jmp	 SHORT $LN2@ObserveQIn
$LN15@ObserveQIn:

; 338  : }

  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c3		 ret	 0
_ObserveQIndiv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\qindiv.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_qIndiv$ = 8						; size = 4
__tkIndiv$ = 12						; size = 4
_LGateNoNorm PROC

; 802  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 803  : 	int i;
; 804  : 
; 805  : 	for (i = 0; i < qIndivLen; i++)

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000b	eb 09		 jmp	 SHORT $LN9@LGateNoNor
$LN8@LGateNoNor:
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00010	83 c0 01	 add	 eax, 1
  00013	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN9@LGateNoNor:
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00019	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _qIndivLen
  0001f	0f 8d 01 01 00
	00		 jge	 $LN10@LGateNoNor

; 806  : 	{
; 807  : 		if (extrons[i] != 0)

  00025	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _extrons
  0002b	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0002e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00031	85 c0		 test	 eax, eax
  00033	0f 84 d6 00 00
	00		 je	 $LN6@LGateNoNor

; 808  : 		{
; 809  : 			LGate2QTokenNoNorm(&(qIndiv[i].funcQT), _tkIndiv->genome[i * 2]); 

  00039	8b 4d 0c	 mov	 ecx, DWORD PTR __tkIndiv$[ebp]
  0003c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00041	0f b6 0c 42	 movzx	 ecx, BYTE PTR [edx+eax*2]
  00045	51		 push	 ecx
  00046	6b 55 fc 0c	 imul	 edx, DWORD PTR _i$[ebp], 12
  0004a	03 55 08	 add	 edx, DWORD PTR _qIndiv$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _LGate2QTokenNoNorm
  00053	83 c4 08	 add	 esp, 8

; 810  : 			if (qIndiv[i].termQTs[_tkIndiv->genome[i * 2]].cardinality > 1)

  00056	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR __tkIndiv$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00062	0f b6 14 4a	 movzx	 edx, BYTE PTR [edx+ecx*2]
  00066	8b 4d 08	 mov	 ecx, DWORD PTR _qIndiv$[ebp]
  00069	8b 44 01 08	 mov	 eax, DWORD PTR [ecx+eax+8]
  0006d	0f b6 0c d0	 movzx	 ecx, BYTE PTR [eax+edx*8]
  00071	83 f9 01	 cmp	 ecx, 1
  00074	0f 8e 93 00 00
	00		 jle	 $LN5@LGateNoNor

; 811  : 			{
; 812  : 				if (!typedTerms)

  0007a	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _typedTerms
  00081	85 d2		 test	 edx, edx
  00083	75 33		 jne	 SHORT $LN4@LGateNoNor

; 813  : 				{
; 814  : 					LGate2QTokenNoNorm(&(qIndiv[i].termQTs[_tkIndiv->genome[i * 2]]),
; 815  : 									   _tkIndiv->genome[i * 2 + 1]);

  00085	8b 45 0c	 mov	 eax, DWORD PTR __tkIndiv$[ebp]
  00088	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0008d	0f b6 44 51 01	 movzx	 eax, BYTE PTR [ecx+edx*2+1]
  00092	50		 push	 eax
  00093	6b 4d fc 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  00097	8b 55 0c	 mov	 edx, DWORD PTR __tkIndiv$[ebp]
  0009a	8b 02		 mov	 eax, DWORD PTR [edx]
  0009c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0009f	0f b6 04 50	 movzx	 eax, BYTE PTR [eax+edx*2]
  000a3	8b 55 08	 mov	 edx, DWORD PTR _qIndiv$[ebp]
  000a6	8b 4c 0a 08	 mov	 ecx, DWORD PTR [edx+ecx+8]
  000aa	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 _LGate2QTokenNoNorm
  000b3	83 c4 08	 add	 esp, 8

; 816  : 					/*LGate2QTokenNoNormLtd(&(qIndiv[i].termQTs[_tkIndiv->genome[i * 2]]),
; 817  : 									   _tkIndiv->genome[i * 2 + 1]);*/
; 818  : 				}
; 819  : 				else

  000b6	eb 55		 jmp	 SHORT $LN5@LGateNoNor
$LN4@LGateNoNor:

; 820  : 				{
; 821  : 					if (termIdxs[_tkIndiv->genome[i * 2]] > 0)

  000b8	8b 45 0c	 mov	 eax, DWORD PTR __tkIndiv$[ebp]
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000c0	0f b6 04 51	 movzx	 eax, BYTE PTR [ecx+edx*2]
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _termIdxs
  000ca	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000ce	85 d2		 test	 edx, edx
  000d0	7e 3b		 jle	 SHORT $LN5@LGateNoNor

; 822  : 					{
; 823  : 						LGate2QTokenNoNorm(&(qIndiv[i].termQTs[termIdxs[_tkIndiv->genome[i * 2]]]),
; 824  : 										   _tkIndiv->genome[i * 2 + 1]);

  000d2	8b 45 0c	 mov	 eax, DWORD PTR __tkIndiv$[ebp]
  000d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d7	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000da	0f b6 44 51 01	 movzx	 eax, BYTE PTR [ecx+edx*2+1]
  000df	50		 push	 eax
  000e0	6b 4d fc 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  000e4	8b 55 0c	 mov	 edx, DWORD PTR __tkIndiv$[ebp]
  000e7	8b 02		 mov	 eax, DWORD PTR [edx]
  000e9	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000ec	0f b6 04 50	 movzx	 eax, BYTE PTR [eax+edx*2]
  000f0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _termIdxs
  000f6	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  000fa	8b 55 08	 mov	 edx, DWORD PTR _qIndiv$[ebp]
  000fd	8b 4c 0a 08	 mov	 ecx, DWORD PTR [edx+ecx+8]
  00101	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00104	52		 push	 edx
  00105	e8 00 00 00 00	 call	 _LGate2QTokenNoNorm
  0010a	83 c4 08	 add	 esp, 8
$LN5@LGateNoNor:

; 825  : 						/*LGate2QTokenNoNormLtd(&(qIndiv[i].termQTs[termIdxs[_tkIndiv->genome[i * 2]]]),
; 826  : 										   _tkIndiv->genome[i * 2 + 1]);*/
; 827  : 					}
; 828  : 				}
; 829  : 			}
; 830  : 		}
; 831  : 		else

  0010d	eb 12		 jmp	 SHORT $LN1@LGateNoNor
$LN6@LGateNoNor:

; 832  : 		{
; 833  : 			LGate2QTokenNoNorm(&(qIndiv[i].funcQT), 0);

  0010f	6a 00		 push	 0
  00111	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00115	03 45 08	 add	 eax, DWORD PTR _qIndiv$[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 _LGate2QTokenNoNorm
  0011e	83 c4 08	 add	 esp, 8
$LN1@LGateNoNor:

; 834  : 		}
; 835  : 	}

  00121	e9 e7 fe ff ff	 jmp	 $LN8@LGateNoNor
$LN10@LGateNoNor:

; 836  : }

  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
_LGateNoNorm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\qindiv.c
_TEXT	SEGMENT
$T1 = -16						; size = 12
_i$ = -4						; size = 4
_qIndiv$ = 8						; size = 4
_InitQIndiv PROC

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 226  : 	register int i;
; 227  : 
; 228  : 	for (i = 0; i < qIndivLen; i++)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN3@InitQIndiv
$LN2@InitQIndiv:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@InitQIndiv:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _qIndivLen
  00021	7d 35		 jge	 SHORT $LN1@InitQIndiv

; 229  : 	{
; 230  : 		qIndiv[i] = InitQLinGene(qNopProb);

  00023	83 ec 08	 sub	 esp, 8
  00026	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _qNopProb
  0002e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00033	8d 55 f0	 lea	 edx, DWORD PTR $T1[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 _InitQLinGene
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003f	6b 4d fc 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  00043	03 4d 08	 add	 ecx, DWORD PTR _qIndiv$[ebp]
  00046	8b 10		 mov	 edx, DWORD PTR [eax]
  00048	89 11		 mov	 DWORD PTR [ecx], edx
  0004a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00050	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00053	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 231  : 	}

  00056	eb b7		 jmp	 SHORT $LN2@InitQIndiv
$LN1@InitQIndiv:

; 232  : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_InitQIndiv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\qindiv.c
_TEXT	SEGMENT
_termIdx$ = -16						; size = 4
_lenPtr$ = -12						; size = 4
_terms$ = -8						; size = 4
_b$ = -3						; size = 1
_t$ = -2						; size = 1
_f$ = -1						; size = 1
_InitSintaticTable PROC

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 11   : 	register byte f, t, b;
; 12   : 	int termIdx;
; 13   : 	byte* lenPtr;
; 14   : 
; 15   : 	// Pointer to terminals: used during sintatic table's reading
; 16   : 	byteList *terms;
; 17   : 
; 18   : 	termIdx = termsDim * mCodeDim;

  00008	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _termsDim
  0000f	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _mCodeDim
  00016	0f af c1	 imul	 eax, ecx
  00019	89 45 f0	 mov	 DWORD PTR _termIdx$[ebp], eax

; 19   : 	sintTable = malloc(nFuncs * sizeof(byteList*));

  0001c	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _nFuncs
  00023	c1 e2 02	 shl	 edx, 2
  00026	52		 push	 edx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0002d	83 c4 04	 add	 esp, 4
  00030	a3 00 00 00 00	 mov	 DWORD PTR _sintTable, eax

; 20   : 	sintTable[0] = NULL; // QNOP has no terminal

  00035	b8 04 00 00 00	 mov	 eax, 4
  0003a	6b c8 00	 imul	 ecx, eax, 0
  0003d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sintTable
  00043	c7 04 0a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx], 0

; 21   : 
; 22   : 	for (f = 1; f < nFuncs; f++)

  0004a	c6 45 ff 01	 mov	 BYTE PTR _f$[ebp], 1
  0004e	eb 08		 jmp	 SHORT $LN9@InitSintat
$LN8@InitSintat:
  00050	8a 45 ff	 mov	 al, BYTE PTR _f$[ebp]
  00053	04 01		 add	 al, 1
  00055	88 45 ff	 mov	 BYTE PTR _f$[ebp], al
$LN9@InitSintat:
  00058	0f b6 4d ff	 movzx	 ecx, BYTE PTR _f$[ebp]
  0005c	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _nFuncs
  00063	3b ca		 cmp	 ecx, edx
  00065	0f 8d 0b 01 00
	00		 jge	 $LN10@InitSintat

; 23   : 	{
; 24   : 		sintTable[f] = malloc(termsCardins[f] * sizeof(byteList));

  0006b	0f b6 45 ff	 movzx	 eax, BYTE PTR _f$[ebp]
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _termsCardins
  00075	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00079	c1 e2 03	 shl	 edx, 3
  0007c	52		 push	 edx
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00083	83 c4 04	 add	 esp, 4
  00086	0f b6 4d ff	 movzx	 ecx, BYTE PTR _f$[ebp]
  0008a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sintTable
  00090	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 25   : 		terms = sintTable[f];

  00093	0f b6 45 ff	 movzx	 eax, BYTE PTR _f$[ebp]
  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sintTable
  0009d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000a0	89 55 f8	 mov	 DWORD PTR _terms$[ebp], edx

; 26   : 		for (t = 0; t < termsCardins[f]; t++)

  000a3	c6 45 fe 00	 mov	 BYTE PTR _t$[ebp], 0
  000a7	eb 08		 jmp	 SHORT $LN6@InitSintat
$LN5@InitSintat:
  000a9	8a 45 fe	 mov	 al, BYTE PTR _t$[ebp]
  000ac	04 01		 add	 al, 1
  000ae	88 45 fe	 mov	 BYTE PTR _t$[ebp], al
$LN6@InitSintat:
  000b1	0f b6 4d fe	 movzx	 ecx, BYTE PTR _t$[ebp]
  000b5	0f b6 55 ff	 movzx	 edx, BYTE PTR _f$[ebp]
  000b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _termsCardins
  000be	0f b6 14 10	 movzx	 edx, BYTE PTR [eax+edx]
  000c2	3b ca		 cmp	 ecx, edx
  000c4	0f 8d a7 00 00
	00		 jge	 $LN4@InitSintat

; 27   : 		{
; 28   : 			lenPtr = mCodesLens + (f * termsDim) + t;

  000ca	0f b6 45 ff	 movzx	 eax, BYTE PTR _f$[ebp]
  000ce	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _termsDim
  000d5	0f af c1	 imul	 eax, ecx
  000d8	03 05 00 00 00
	00		 add	 eax, DWORD PTR _mCodesLens
  000de	0f b6 55 fe	 movzx	 edx, BYTE PTR _t$[ebp]
  000e2	03 c2		 add	 eax, edx
  000e4	89 45 f4	 mov	 DWORD PTR _lenPtr$[ebp], eax

; 29   : 			terms[t].length = *lenPtr;

  000e7	0f b6 45 fe	 movzx	 eax, BYTE PTR _t$[ebp]
  000eb	8b 4d f4	 mov	 ecx, DWORD PTR _lenPtr$[ebp]
  000ee	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000f1	8b 4d f8	 mov	 ecx, DWORD PTR _terms$[ebp]
  000f4	89 54 c1 04	 mov	 DWORD PTR [ecx+eax*8+4], edx

; 30   : 			terms[t].list = malloc(terms[t].length * sizeof(byte));

  000f8	0f b6 55 fe	 movzx	 edx, BYTE PTR _t$[ebp]
  000fc	8b 45 f8	 mov	 eax, DWORD PTR _terms$[ebp]
  000ff	8b 4c d0 04	 mov	 ecx, DWORD PTR [eax+edx*8+4]
  00103	51		 push	 ecx
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0010a	83 c4 04	 add	 esp, 4
  0010d	0f b6 55 fe	 movzx	 edx, BYTE PTR _t$[ebp]
  00111	8b 4d f8	 mov	 ecx, DWORD PTR _terms$[ebp]
  00114	89 04 d1	 mov	 DWORD PTR [ecx+edx*8], eax

; 31   : 			for (b = 0; b < *lenPtr; b++)

  00117	c6 45 fd 00	 mov	 BYTE PTR _b$[ebp], 0
  0011b	eb 09		 jmp	 SHORT $LN3@InitSintat
$LN2@InitSintat:
  0011d	8a 55 fd	 mov	 dl, BYTE PTR _b$[ebp]
  00120	80 c2 01	 add	 dl, 1
  00123	88 55 fd	 mov	 BYTE PTR _b$[ebp], dl
$LN3@InitSintat:
  00126	0f b6 45 fd	 movzx	 eax, BYTE PTR _b$[ebp]
  0012a	8b 4d f4	 mov	 ecx, DWORD PTR _lenPtr$[ebp]
  0012d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00130	3b c2		 cmp	 eax, edx
  00132	7d 38		 jge	 SHORT $LN1@InitSintat

; 32   : 			{
; 33   : 				terms[t].list[b] = *(mCodeTable + (f * termIdx) + (t * mCodeDim) + b);

  00134	0f b6 45 ff	 movzx	 eax, BYTE PTR _f$[ebp]
  00138	0f af 45 f0	 imul	 eax, DWORD PTR _termIdx$[ebp]
  0013c	03 05 00 00 00
	00		 add	 eax, DWORD PTR _mCodeTable
  00142	0f b6 4d fe	 movzx	 ecx, BYTE PTR _t$[ebp]
  00146	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _mCodeDim
  0014d	0f af ca	 imul	 ecx, edx
  00150	03 c1		 add	 eax, ecx
  00152	0f b6 4d fd	 movzx	 ecx, BYTE PTR _b$[ebp]
  00156	0f b6 55 fe	 movzx	 edx, BYTE PTR _t$[ebp]
  0015a	0f b6 75 fd	 movzx	 esi, BYTE PTR _b$[ebp]
  0015e	8b 7d f8	 mov	 edi, DWORD PTR _terms$[ebp]
  00161	8b 14 d7	 mov	 edx, DWORD PTR [edi+edx*8]
  00164	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00167	88 04 32	 mov	 BYTE PTR [edx+esi], al

; 34   : 			}

  0016a	eb b1		 jmp	 SHORT $LN2@InitSintat
$LN1@InitSintat:

; 35   : 		}

  0016c	e9 38 ff ff ff	 jmp	 $LN5@InitSintat
$LN4@InitSintat:

; 36   : 	}

  00171	e9 da fe ff ff	 jmp	 $LN8@InitSintat
$LN10@InitSintat:

; 37   : }

  00176	5f		 pop	 edi
  00177	5e		 pop	 esi
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
_InitSintaticTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\qindiv.c
_TEXT	SEGMENT
__qNopProb$ = -20					; size = 8
_qT$ = -12						; size = 8
_i$ = -1						; size = 1
__nFuncs$ = 8						; size = 1
_nopProb$ = 12						; size = 8
_InitFuncQToken PROC

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 85   : 	qToken qT;
; 86   : 	register byte i;
; 87   : 	double _qNopProb = (1 - nopProb) / (_nFuncs - 1);

  00006	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0000e	f2 0f 5c 45 0c	 subsd	 xmm0, QWORD PTR _nopProb$[ebp]
  00013	0f b6 45 08	 movzx	 eax, BYTE PTR __nFuncs$[ebp]
  00017	83 e8 01	 sub	 eax, 1
  0001a	f2 0f 2a c8	 cvtsi2sd xmm1, eax
  0001e	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00022	f2 0f 11 45 ec	 movsd	 QWORD PTR __qNopProb$[ebp], xmm0

; 88   : 
; 89   : 	qT.alphas = malloc(_nFuncs * sizeof(double));

  00027	0f b6 4d 08	 movzx	 ecx, BYTE PTR __nFuncs$[ebp]
  0002b	c1 e1 03	 shl	 ecx, 3
  0002e	51		 push	 ecx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00035	83 c4 04	 add	 esp, 4
  00038	89 45 f8	 mov	 DWORD PTR _qT$[ebp+4], eax

; 90   : 	qT.cardinality = _nFuncs;

  0003b	8a 55 08	 mov	 dl, BYTE PTR __nFuncs$[ebp]
  0003e	88 55 f4	 mov	 BYTE PTR _qT$[ebp], dl

; 91   : 	qT.alphas[0] = nopProb;

  00041	b8 08 00 00 00	 mov	 eax, 8
  00046	6b c8 00	 imul	 ecx, eax, 0
  00049	8b 55 f8	 mov	 edx, DWORD PTR _qT$[ebp+4]
  0004c	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _nopProb$[ebp]
  00051	f2 0f 11 04 0a	 movsd	 QWORD PTR [edx+ecx], xmm0

; 92   : 	for (i = 1; i < nFuncs; i++)

  00056	c6 45 ff 01	 mov	 BYTE PTR _i$[ebp], 1
  0005a	eb 08		 jmp	 SHORT $LN3@InitFuncQT
$LN2@InitFuncQT:
  0005c	8a 45 ff	 mov	 al, BYTE PTR _i$[ebp]
  0005f	04 01		 add	 al, 1
  00061	88 45 ff	 mov	 BYTE PTR _i$[ebp], al
$LN3@InitFuncQT:
  00064	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$[ebp]
  00068	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _nFuncs
  0006f	3b ca		 cmp	 ecx, edx
  00071	7d 20		 jge	 SHORT $LN1@InitFuncQT

; 93   : 	{
; 94   : 		qT.alphas[i] = qT.alphas[i - 1] + _qNopProb;

  00073	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _qT$[ebp+4]
  0007a	f2 0f 10 44 c1
	f8		 movsd	 xmm0, QWORD PTR [ecx+eax*8-8]
  00080	f2 0f 58 45 ec	 addsd	 xmm0, QWORD PTR __qNopProb$[ebp]
  00085	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  00089	8b 45 f8	 mov	 eax, DWORD PTR _qT$[ebp+4]
  0008c	f2 0f 11 04 d0	 movsd	 QWORD PTR [eax+edx*8], xmm0

; 95   : 	}

  00091	eb c9		 jmp	 SHORT $LN2@InitFuncQT
$LN1@InitFuncQT:

; 96   : 	
; 97   : 	return qT;

  00093	8b 45 f4	 mov	 eax, DWORD PTR _qT$[ebp]
  00096	8b 55 f8	 mov	 edx, DWORD PTR _qT$[ebp+4]

; 98   : }

  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_InitFuncQToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\qindiv.c
_TEXT	SEGMENT
tv92 = -12						; size = 8
_i$ = -1						; size = 1
_qT$ = 8						; size = 4
_ObserveQToken PROC

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 104  : 	register byte i;
; 105  : 	static double randNum;
; 106  : 	
; 107  : 	if (qT == NULL)

  00008	83 7d 08 00	 cmp	 DWORD PTR _qT$[ebp], 0
  0000c	75 04		 jne	 SHORT $LN5@ObserveQTo

; 108  : 		return 0;

  0000e	32 c0		 xor	 al, al
  00010	eb 6a		 jmp	 SHORT $LN6@ObserveQTo
$LN5@ObserveQTo:

; 109  : 	
; 110  : 	//randNum = (double)rand() / RAND_MAX; // For normalized qtoken
; 111  : 	//randNum = qT->alphas[qT->cardinality - 1] * (double)rand() / RAND_MAX; // For non normalized
; 112  : 	randNum = qT->alphas[qT->cardinality - 1] * genrand_real1();

  00012	8b 45 08	 mov	 eax, DWORD PTR _qT$[ebp]
  00015	0f b6 30	 movzx	 esi, BYTE PTR [eax]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _qT$[ebp]
  0001b	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  0001e	e8 00 00 00 00	 call	 _genrand_real1
  00023	dd 5d f4	 fstp	 QWORD PTR tv92[ebp]
  00026	f2 0f 10 45 f4	 movsd	 xmm0, QWORD PTR tv92[ebp]
  0002b	f2 0f 59 44 f7
	f8		 mulsd	 xmm0, QWORD PTR [edi+esi*8-8]
  00031	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?randNum@?1??ObserveQToken@@9@9, xmm0

; 113  : 
; 114  : 	for (i = 0; i < qT->cardinality - 1; i++)

  00039	c6 45 ff 00	 mov	 BYTE PTR _i$[ebp], 0
  0003d	eb 09		 jmp	 SHORT $LN4@ObserveQTo
$LN3@ObserveQTo:
  0003f	8a 55 ff	 mov	 dl, BYTE PTR _i$[ebp]
  00042	80 c2 01	 add	 dl, 1
  00045	88 55 ff	 mov	 BYTE PTR _i$[ebp], dl
$LN4@ObserveQTo:
  00048	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _qT$[ebp]
  0004f	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00052	83 ea 01	 sub	 edx, 1
  00055	3b c2		 cmp	 eax, edx
  00057	7d 20		 jge	 SHORT $LN2@ObserveQTo

; 115  : 	{
; 116  : 		if (randNum < qT->alphas[i])

  00059	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _qT$[ebp]
  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	f2 0f 10 04 c2	 movsd	 xmm0, QWORD PTR [edx+eax*8]
  00068	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR ?randNum@?1??ObserveQToken@@9@9
  00070	76 05		 jbe	 SHORT $LN1@ObserveQTo

; 117  : 		{
; 118  : 			return i;

  00072	8a 45 ff	 mov	 al, BYTE PTR _i$[ebp]
  00075	eb 05		 jmp	 SHORT $LN6@ObserveQTo
$LN1@ObserveQTo:

; 119  : 		}
; 120  : 	}

  00077	eb c6		 jmp	 SHORT $LN3@ObserveQTo
$LN2@ObserveQTo:

; 121  : 
; 122  : 	return i;

  00079	8a 45 ff	 mov	 al, BYTE PTR _i$[ebp]
$LN6@ObserveQTo:

; 123  : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_ObserveQToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\qindiv.c
_TEXT	SEGMENT
_i$ = -1						; size = 1
_qT$ = 8						; size = 4
__nFuncs$ = 12						; size = 1
_nopProb$ = 16						; size = 8
_ResetFuncQToken PROC

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 152  : 	register byte i;
; 153  : 	static double _qNopProb;
; 154  : 
; 155  : 	_qNopProb = (1 - nopProb) / (_nFuncs - 1);

  00004	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0000c	f2 0f 5c 45 10	 subsd	 xmm0, QWORD PTR _nopProb$[ebp]
  00011	0f b6 45 0c	 movzx	 eax, BYTE PTR __nFuncs$[ebp]
  00015	83 e8 01	 sub	 eax, 1
  00018	f2 0f 2a c8	 cvtsi2sd xmm1, eax
  0001c	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00020	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?_qNopProb@?1??ResetFuncQToken@@9@9, xmm0

; 156  : 	qT->alphas[0] = nopProb;

  00028	b9 08 00 00 00	 mov	 ecx, 8
  0002d	6b d1 00	 imul	 edx, ecx, 0
  00030	8b 45 08	 mov	 eax, DWORD PTR _qT$[ebp]
  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _nopProb$[ebp]
  0003b	f2 0f 11 04 0a	 movsd	 QWORD PTR [edx+ecx], xmm0

; 157  : 	for (i = 1; i < nFuncs; i++)

  00040	c6 45 ff 01	 mov	 BYTE PTR _i$[ebp], 1
  00044	eb 09		 jmp	 SHORT $LN3@ResetFuncQ
$LN2@ResetFuncQ:
  00046	8a 55 ff	 mov	 dl, BYTE PTR _i$[ebp]
  00049	80 c2 01	 add	 dl, 1
  0004c	88 55 ff	 mov	 BYTE PTR _i$[ebp], dl
$LN3@ResetFuncQ:
  0004f	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  00053	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _nFuncs
  0005a	3b c1		 cmp	 eax, ecx
  0005c	7d 29		 jge	 SHORT $LN1@ResetFuncQ

; 158  : 	{
; 159  : 		qT->alphas[i] = qT->alphas[i - 1] + _qNopProb;

  0005e	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  00062	8b 45 08	 mov	 eax, DWORD PTR _qT$[ebp]
  00065	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00068	f2 0f 10 44 d1
	f8		 movsd	 xmm0, QWORD PTR [ecx+edx*8-8]
  0006e	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR ?_qNopProb@?1??ResetFuncQToken@@9@9
  00076	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  0007a	8b 45 08	 mov	 eax, DWORD PTR _qT$[ebp]
  0007d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00080	f2 0f 11 04 d1	 movsd	 QWORD PTR [ecx+edx*8], xmm0

; 160  : 	}

  00085	eb bf		 jmp	 SHORT $LN2@ResetFuncQ
$LN1@ResetFuncQ:

; 161  : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
_ResetFuncQToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\qindiv.c
_TEXT	SEGMENT
_i$ = -1						; size = 1
_qT$ = 8						; size = 4
_cardinality$ = 12					; size = 1
_ResetQToken PROC

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 165  : 	register byte i;
; 166  : 	static double probStep;
; 167  : 
; 168  : 	if (cardinality == 0)

  00004	0f b6 45 0c	 movzx	 eax, BYTE PTR _cardinality$[ebp]
  00008	85 c0		 test	 eax, eax
  0000a	75 15		 jne	 SHORT $LN13@ResetQToke

; 169  : 	{
; 170  : 		probStep = 1.0;

  0000c	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00014	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?probStep@?1??ResetQToken@@9@9, xmm0
  0001c	e9 6b 01 00 00	 jmp	 $LN1@ResetQToke
$LN13@ResetQToke:

; 171  : 	}
; 172  : 	else if (cardinality == nVars + nConsts)

  00021	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cardinality$[ebp]
  00025	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nVars
  0002b	03 15 00 00 00
	00		 add	 edx, DWORD PTR _nConsts
  00031	3b ca		 cmp	 ecx, edx
  00033	0f 85 d8 00 00
	00		 jne	 $LN11@ResetQToke

; 173  : 	{
; 174  : 		probStep = 0.5 / nVars;

  00039	f2 0f 2a 05 00
	00 00 00	 cvtsi2sd xmm0, DWORD PTR _nVars
  00041	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3fe0000000000000
  00049	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0004d	f2 0f 11 0d 00
	00 00 00	 movsd	 QWORD PTR ?probStep@?1??ResetQToken@@9@9, xmm1

; 175  : 		qT->alphas[0] = probStep;

  00055	b8 08 00 00 00	 mov	 eax, 8
  0005a	6b c8 00	 imul	 ecx, eax, 0
  0005d	8b 55 08	 mov	 edx, DWORD PTR _qT$[ebp]
  00060	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00063	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR ?probStep@?1??ResetQToken@@9@9
  0006b	f2 0f 11 04 01	 movsd	 QWORD PTR [ecx+eax], xmm0

; 176  : 		for (i = 1; i < nVars; i++)

  00070	c6 45 ff 01	 mov	 BYTE PTR _i$[ebp], 1
  00074	eb 09		 jmp	 SHORT $LN10@ResetQToke
$LN9@ResetQToke:
  00076	8a 4d ff	 mov	 cl, BYTE PTR _i$[ebp]
  00079	80 c1 01	 add	 cl, 1
  0007c	88 4d ff	 mov	 BYTE PTR _i$[ebp], cl
$LN10@ResetQToke:
  0007f	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  00083	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _nVars
  00089	7d 29		 jge	 SHORT $LN8@ResetQToke

; 177  : 		{
; 178  : 			qT->alphas[i] = qT->alphas[i - 1] + probStep;

  0008b	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _qT$[ebp]
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	f2 0f 10 44 c2
	f8		 movsd	 xmm0, QWORD PTR [edx+eax*8-8]
  0009b	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR ?probStep@?1??ResetQToken@@9@9
  000a3	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR _qT$[ebp]
  000aa	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ad	f2 0f 11 04 c2	 movsd	 QWORD PTR [edx+eax*8], xmm0

; 179  : 		}

  000b2	eb c2		 jmp	 SHORT $LN9@ResetQToke
$LN8@ResetQToke:

; 180  : 		probStep = 0.5 / nConsts;

  000b4	f2 0f 2a 05 00
	00 00 00	 cvtsi2sd xmm0, DWORD PTR _nConsts
  000bc	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3fe0000000000000
  000c4	f2 0f 5e c8	 divsd	 xmm1, xmm0
  000c8	f2 0f 11 0d 00
	00 00 00	 movsd	 QWORD PTR ?probStep@?1??ResetQToken@@9@9, xmm1

; 181  : 		for (; i < cardinality; i++)

  000d0	eb 08		 jmp	 SHORT $LN7@ResetQToke
$LN6@ResetQToke:
  000d2	8a 45 ff	 mov	 al, BYTE PTR _i$[ebp]
  000d5	04 01		 add	 al, 1
  000d7	88 45 ff	 mov	 BYTE PTR _i$[ebp], al
$LN7@ResetQToke:
  000da	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$[ebp]
  000de	0f b6 55 0c	 movzx	 edx, BYTE PTR _cardinality$[ebp]
  000e2	3b ca		 cmp	 ecx, edx
  000e4	7d 29		 jge	 SHORT $LN5@ResetQToke

; 182  : 		{
; 183  : 			qT->alphas[i] = qT->alphas[i - 1] + probStep;

  000e6	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _qT$[ebp]
  000ed	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000f0	f2 0f 10 44 c2
	f8		 movsd	 xmm0, QWORD PTR [edx+eax*8-8]
  000f6	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR ?probStep@?1??ResetQToken@@9@9
  000fe	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  00102	8b 4d 08	 mov	 ecx, DWORD PTR _qT$[ebp]
  00105	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00108	f2 0f 11 04 c2	 movsd	 QWORD PTR [edx+eax*8], xmm0

; 184  : 		}

  0010d	eb c3		 jmp	 SHORT $LN6@ResetQToke
$LN5@ResetQToke:

; 185  : 	}
; 186  : 	else

  0010f	eb 7b		 jmp	 SHORT $LN1@ResetQToke
$LN11@ResetQToke:

; 187  : 	{
; 188  : 		probStep = (1.0 / cardinality);

  00111	0f b6 45 0c	 movzx	 eax, BYTE PTR _cardinality$[ebp]
  00115	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00119	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00121	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00125	f2 0f 11 0d 00
	00 00 00	 movsd	 QWORD PTR ?probStep@?1??ResetQToken@@9@9, xmm1

; 189  : 		qT->alphas[0] = probStep;

  0012d	b9 08 00 00 00	 mov	 ecx, 8
  00132	6b d1 00	 imul	 edx, ecx, 0
  00135	8b 45 08	 mov	 eax, DWORD PTR _qT$[ebp]
  00138	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013b	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR ?probStep@?1??ResetQToken@@9@9
  00143	f2 0f 11 04 0a	 movsd	 QWORD PTR [edx+ecx], xmm0

; 190  : 		for (i = 1; i < cardinality; i++)

  00148	c6 45 ff 01	 mov	 BYTE PTR _i$[ebp], 1
  0014c	eb 09		 jmp	 SHORT $LN3@ResetQToke
$LN2@ResetQToke:
  0014e	8a 55 ff	 mov	 dl, BYTE PTR _i$[ebp]
  00151	80 c2 01	 add	 dl, 1
  00154	88 55 ff	 mov	 BYTE PTR _i$[ebp], dl
$LN3@ResetQToke:
  00157	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  0015b	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cardinality$[ebp]
  0015f	3b c1		 cmp	 eax, ecx
  00161	7d 29		 jge	 SHORT $LN1@ResetQToke

; 191  : 		{
; 192  : 			qT->alphas[i] = qT->alphas[i - 1] + probStep;

  00163	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  00167	8b 45 08	 mov	 eax, DWORD PTR _qT$[ebp]
  0016a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0016d	f2 0f 10 44 d1
	f8		 movsd	 xmm0, QWORD PTR [ecx+edx*8-8]
  00173	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR ?probStep@?1??ResetQToken@@9@9
  0017b	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  0017f	8b 45 08	 mov	 eax, DWORD PTR _qT$[ebp]
  00182	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00185	f2 0f 11 04 d1	 movsd	 QWORD PTR [ecx+edx*8], xmm0

; 193  : 		}

  0018a	eb c2		 jmp	 SHORT $LN2@ResetQToke
$LN1@ResetQToke:

; 194  : 	}
; 195  : 	
; 196  : }

  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c3		 ret	 0
_ResetQToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\qindiv.c
_TEXT	SEGMENT
_qGene$ = -16						; size = 12
_i$ = -1						; size = 1
$T1 = 8							; size = 4
_nopProb$ = 12						; size = 8
_InitQLinGene PROC

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 200  : 	qGene qGene;
; 201  : 	register byte i;
; 202  : 
; 203  : 	qGene.funcQT = InitFuncQToken(nFuncs, nopProb);

  00007	83 ec 08	 sub	 esp, 8
  0000a	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _nopProb$[ebp]
  0000f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00014	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _nFuncs
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _InitFuncQToken
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	89 45 f0	 mov	 DWORD PTR _qGene$[ebp], eax
  00027	89 55 f4	 mov	 DWORD PTR _qGene$[ebp+4], edx

; 204  : 	qGene.termQTs = malloc(nFuncs * sizeof(qToken));

  0002a	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _nFuncs
  00031	c1 e1 03	 shl	 ecx, 3
  00034	51		 push	 ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f8	 mov	 DWORD PTR _qGene$[ebp+8], eax

; 205  : 	for (i = 0; i < nFuncs; i++)

  00041	c6 45 ff 00	 mov	 BYTE PTR _i$[ebp], 0
  00045	eb 09		 jmp	 SHORT $LN3@InitQLinGe
$LN2@InitQLinGe:
  00047	8a 55 ff	 mov	 dl, BYTE PTR _i$[ebp]
  0004a	80 c2 01	 add	 dl, 1
  0004d	88 55 ff	 mov	 BYTE PTR _i$[ebp], dl
$LN3@InitQLinGe:
  00050	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  00054	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _nFuncs
  0005b	3b c1		 cmp	 eax, ecx
  0005d	7d 26		 jge	 SHORT $LN1@InitQLinGe

; 206  : 	{
; 207  : 		qGene.termQTs[i] = InitQToken(termsCardins[i]);

  0005f	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _termsCardins
  00068	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 _InitQToken
  00072	83 c4 04	 add	 esp, 4
  00075	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$[ebp]
  00079	8b 75 f8	 mov	 esi, DWORD PTR _qGene$[ebp+8]
  0007c	89 04 ce	 mov	 DWORD PTR [esi+ecx*8], eax
  0007f	89 54 ce 04	 mov	 DWORD PTR [esi+ecx*8+4], edx

; 208  : 	}

  00083	eb c2		 jmp	 SHORT $LN2@InitQLinGe
$LN1@InitQLinGe:

; 209  : 	return qGene;

  00085	8b 55 08	 mov	 edx, DWORD PTR $T1[ebp]
  00088	8b 45 f0	 mov	 eax, DWORD PTR _qGene$[ebp]
  0008b	89 02		 mov	 DWORD PTR [edx], eax
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR _qGene$[ebp+4]
  00090	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00093	8b 45 f8	 mov	 eax, DWORD PTR _qGene$[ebp+8]
  00096	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00099	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]

; 210  : }

  0009c	5e		 pop	 esi
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
_InitQLinGene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\qindiv.c
_TEXT	SEGMENT
_i$ = -1						; size = 1
_qG$ = 8						; size = 4
_nopProb$ = 12						; size = 8
_ResetQGene PROC

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 214  :     register byte i;
; 215  : 
; 216  : 	ResetFuncQToken(&qG->funcQT, nFuncs, nopProb);

  00004	83 ec 08	 sub	 esp, 8
  00007	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _nopProb$[ebp]
  0000c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00011	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _nFuncs
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _qG$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 _ResetFuncQToken
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 217  : 	for (i = 0; i < nFuncs; i++)

  00025	c6 45 ff 00	 mov	 BYTE PTR _i$[ebp], 0
  00029	eb 09		 jmp	 SHORT $LN3@ResetQGene
$LN2@ResetQGene:
  0002b	8a 55 ff	 mov	 dl, BYTE PTR _i$[ebp]
  0002e	80 c2 01	 add	 dl, 1
  00031	88 55 ff	 mov	 BYTE PTR _i$[ebp], dl
$LN3@ResetQGene:
  00034	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  00038	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _nFuncs
  0003f	3b c1		 cmp	 eax, ecx
  00041	7d 26		 jge	 SHORT $LN1@ResetQGene

; 218  : 	{
; 219  : 		 ResetQToken(&qG->termQTs[i], termsCardins[i]);

  00043	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _termsCardins
  0004c	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00050	51		 push	 ecx
  00051	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  00055	8b 45 08	 mov	 eax, DWORD PTR _qG$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	8d 14 d1	 lea	 edx, DWORD PTR [ecx+edx*8]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 _ResetQToken
  00064	83 c4 08	 add	 esp, 8

; 220  : 	}

  00067	eb c2		 jmp	 SHORT $LN2@ResetQGene
$LN1@ResetQGene:

; 221  : }

  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_ResetQGene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\qindiv.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_qT$ = 8						; size = 4
_token$ = 12						; size = 1
_LGate2QTokenNoNorm PROC

; 580  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 581  : 	register int i;
; 582  : 	static int lastTkIdx;
; 583  : 	static double inc;
; 584  : 	//static byte limit, card;
; 585  : 
; 586  : 	lastTkIdx = qT->cardinality - 1;

  00006	8b 45 08	 mov	 eax, DWORD PTR _qT$[ebp]
  00009	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0000c	83 e9 01	 sub	 ecx, 1
  0000f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?lastTkIdx@?1??LGate2QTokenNoNorm@@9@9, ecx

; 587  : 
; 588  :  	if (token == 0)

  00015	0f b6 55 0c	 movzx	 edx, BYTE PTR _token$[ebp]
  00019	85 d2		 test	 edx, edx
  0001b	75 36		 jne	 SHORT $LN5@LGate2QTok

; 589  : 	{
; 590  : 		//limit = (qT->alphas[0] / qT->alphas[lastTkIdx]) < 0.98;
; 591  : 		inc = lGateStep * (qT->alphas[lastTkIdx] - qT->alphas[0]);

  0001d	8b 45 08	 mov	 eax, DWORD PTR _qT$[ebp]
  00020	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00023	ba 08 00 00 00	 mov	 edx, 8
  00028	6b c2 00	 imul	 eax, edx, 0
  0002b	8b 55 08	 mov	 edx, DWORD PTR _qT$[ebp]
  0002e	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00031	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?lastTkIdx@?1??LGate2QTokenNoNorm@@9@9
  00037	f2 0f 10 04 f1	 movsd	 xmm0, QWORD PTR [ecx+esi*8]
  0003c	f2 0f 5c 04 02	 subsd	 xmm0, QWORD PTR [edx+eax]
  00041	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR _lGateStep
  00049	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?inc@?1??LGate2QTokenNoNorm@@9@9, xmm0

; 592  : 		//if (!limit) printf(" f gt 0.98 ");
; 593  : 	}
; 594  :     else 

  00051	eb 44		 jmp	 SHORT $LN4@LGate2QTok
$LN5@LGate2QTok:

; 595  :     {
; 596  : 		//limit = ((qT->alphas[token] - qT->alphas[token-1]) / qT->alphas[lastTkIdx]) < 0.98;
; 597  :         inc = lGateStep * (qT->alphas[lastTkIdx] - (qT->alphas[token] - qT->alphas[token-1]));

  00053	8b 45 08	 mov	 eax, DWORD PTR _qT$[ebp]
  00056	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00059	0f b6 55 0c	 movzx	 edx, BYTE PTR _token$[ebp]
  0005d	8b 45 08	 mov	 eax, DWORD PTR _qT$[ebp]
  00060	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00063	0f b6 75 0c	 movzx	 esi, BYTE PTR _token$[ebp]
  00067	8b 7d 08	 mov	 edi, DWORD PTR _qT$[ebp]
  0006a	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  0006d	f2 0f 10 04 d0	 movsd	 xmm0, QWORD PTR [eax+edx*8]
  00072	f2 0f 5c 44 f7
	f8		 subsd	 xmm0, QWORD PTR [edi+esi*8-8]
  00078	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?lastTkIdx@?1??LGate2QTokenNoNorm@@9@9
  0007e	f2 0f 10 0c d1	 movsd	 xmm1, QWORD PTR [ecx+edx*8]
  00083	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00087	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR _lGateStep
  0008f	f2 0f 11 0d 00
	00 00 00	 movsd	 QWORD PTR ?inc@?1??LGate2QTokenNoNorm@@9@9, xmm1
$LN4@LGate2QTok:

; 598  : 		//if (!limit)
; 599  : 		//{
; 600  : 		//	printf(" t gt 0.98 ");
; 601  : 		//}
; 602  :     }
; 603  : 	//card = limit * qT->cardinality;
; 604  : 	for (i = token; i < qT->cardinality; i++)

  00097	0f b6 45 0c	 movzx	 eax, BYTE PTR _token$[ebp]
  0009b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  0009e	eb 09		 jmp	 SHORT $LN3@LGate2QTok
$LN2@LGate2QTok:
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000a3	83 c1 01	 add	 ecx, 1
  000a6	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN3@LGate2QTok:
  000a9	8b 55 08	 mov	 edx, DWORD PTR _qT$[ebp]
  000ac	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000af	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  000b2	7d 26		 jge	 SHORT $LN1@LGate2QTok

; 605  : 	{
; 606  : 		qT->alphas[i] += inc;

  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _qT$[ebp]
  000b7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ba	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000bd	f2 0f 10 04 c2	 movsd	 xmm0, QWORD PTR [edx+eax*8]
  000c2	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR ?inc@?1??LGate2QTokenNoNorm@@9@9
  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _qT$[ebp]
  000cd	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d3	f2 0f 11 04 c2	 movsd	 QWORD PTR [edx+eax*8], xmm0

; 607  : 	}

  000d8	eb c6		 jmp	 SHORT $LN2@LGate2QTok
$LN1@LGate2QTok:

; 608  : 	
; 609  : 	return 0;

  000da	32 c0		 xor	 al, al

; 610  : }

  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
_LGate2QTokenNoNorm ENDP
_TEXT	ENDS
END
