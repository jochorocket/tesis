; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	D:\JOCHO\sanpa\seminario de tesis\QILGP\QILGP\utils.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

?r@?1??IsTkIndivBetter@@9@9 DB 01H DUP (?)		; `IsTkIndivBetter'::`2'::r
_BSS	ENDS
PUBLIC	_IsTkIndivBetter
PUBLIC	_NoRepeat
PUBLIC	_InsertSortLen
?auxTkIndiv@?1??NoRepeat@@9@9 DB 028H DUP (?)		; `NoRepeat'::`2'::auxTkIndiv
?tkIndivAux@?1??InsertSortLen@@9@9 DB 028H DUP (?)	; `InsertSortLen'::`2'::tkIndivAux
_BSS	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\utils.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_j$ = -4						; size = 4
_tkIndivs$ = 8						; size = 4
_length$ = 12						; size = 4
_InsertSortLen PROC

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 36   :     unsigned int i, j;
; 37   : 	static struct tkIndiv tkIndivAux;
; 38   : 	
; 39   :     for (i = 1; i < length; i++)

  00008	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0000f	eb 09		 jmp	 SHORT $LN6@InsertSort
$LN5@InsertSort:
  00011	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00014	83 c0 01	 add	 eax, 1
  00017	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN6@InsertSort:
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0001d	3b 4d 0c	 cmp	 ecx, DWORD PTR _length$[ebp]
  00020	73 7f		 jae	 SHORT $LN7@InsertSort

; 40   : 	{
; 41   : 		tkIndivAux = tkIndivs[i];

  00022	6b 75 f8 28	 imul	 esi, DWORD PTR _i$[ebp], 40
  00026	03 75 08	 add	 esi, DWORD PTR _tkIndivs$[ebp]
  00029	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0002e	bf 00 00 00 00	 mov	 edi, OFFSET ?tkIndivAux@?1??InsertSortLen@@9@9
  00033	f3 a5		 rep movsd

; 42   : 		for (j = i;
; 43   : 			 //(j > 0) && IsTkIndivBetterError(&tkIndivs[j-1], &tkIndivAux);
; 44   :              (j > 0) && IsTkIndivBetter(&tkIndivs[j-1], &tkIndivAux);
; 45   : 		     j--)

  00035	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00038	89 55 fc	 mov	 DWORD PTR _j$[ebp], edx
  0003b	eb 09		 jmp	 SHORT $LN3@InsertSort
$LN2@InsertSort:
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _j$[ebp]
  00040	83 e8 01	 sub	 eax, 1
  00043	89 45 fc	 mov	 DWORD PTR _j$[ebp], eax
$LN3@InsertSort:
  00046	83 7d fc 00	 cmp	 DWORD PTR _j$[ebp], 0
  0004a	76 3d		 jbe	 SHORT $LN1@InsertSort
  0004c	68 00 00 00 00	 push	 OFFSET ?tkIndivAux@?1??InsertSortLen@@9@9
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _j$[ebp]
  00054	83 e9 01	 sub	 ecx, 1
  00057	6b d1 28	 imul	 edx, ecx, 40
  0005a	03 55 08	 add	 edx, DWORD PTR _tkIndivs$[ebp]
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 _IsTkIndivBetter
  00063	83 c4 08	 add	 esp, 8
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	74 1c		 je	 SHORT $LN1@InsertSort

; 46   : 		{
; 47   : 			tkIndivs[j] = tkIndivs[j - 1];

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _j$[ebp]
  00070	83 e9 01	 sub	 ecx, 1
  00073	6b f1 28	 imul	 esi, ecx, 40
  00076	03 75 08	 add	 esi, DWORD PTR _tkIndivs$[ebp]
  00079	6b 7d fc 28	 imul	 edi, DWORD PTR _j$[ebp], 40
  0007d	03 7d 08	 add	 edi, DWORD PTR _tkIndivs$[ebp]
  00080	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00085	f3 a5		 rep movsd

; 48   :         }

  00087	eb b4		 jmp	 SHORT $LN2@InsertSort
$LN1@InsertSort:

; 49   : 		tkIndivs[j] = tkIndivAux;

  00089	6b 7d fc 28	 imul	 edi, DWORD PTR _j$[ebp], 40
  0008d	03 7d 08	 add	 edi, DWORD PTR _tkIndivs$[ebp]
  00090	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00095	be 00 00 00 00	 mov	 esi, OFFSET ?tkIndivAux@?1??InsertSortLen@@9@9
  0009a	f3 a5		 rep movsd

; 50   :     }

  0009c	e9 70 ff ff ff	 jmp	 $LN5@InsertSort
$LN7@InsertSort:

; 51   : }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
_InsertSortLen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\utils.c
_TEXT	SEGMENT
_j$ = -2						; size = 1
_i$ = -1						; size = 1
_tkIndivs$ = 8						; size = 4
_length$ = 12						; size = 4
_NoRepeat PROC

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 153  : 	register byte i, j;
; 154  : 	static struct tkIndiv auxTkIndiv;
; 155  : 
; 156  : 	for (i = 0; i < popSize-1; i++)

  00006	c6 45 ff 00	 mov	 BYTE PTR _i$[ebp], 0
  0000a	eb 08		 jmp	 SHORT $LN7@NoRepeat
$LN6@NoRepeat:
  0000c	8a 45 ff	 mov	 al, BYTE PTR _i$[ebp]
  0000f	04 01		 add	 al, 1
  00011	88 45 ff	 mov	 BYTE PTR _i$[ebp], al
$LN7@NoRepeat:
  00014	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$[ebp]
  00018	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _popSize
  0001e	83 ea 01	 sub	 edx, 1
  00021	3b ca		 cmp	 ecx, edx
  00023	0f 83 99 00 00
	00		 jae	 $LN5@NoRepeat

; 157  : 	{
; 158  : 		for (j = i+1; j < length; j++)

  00029	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  0002d	83 c0 01	 add	 eax, 1
  00030	88 45 fe	 mov	 BYTE PTR _j$[ebp], al
  00033	eb 09		 jmp	 SHORT $LN4@NoRepeat
$LN3@NoRepeat:
  00035	8a 4d fe	 mov	 cl, BYTE PTR _j$[ebp]
  00038	80 c1 01	 add	 cl, 1
  0003b	88 4d fe	 mov	 BYTE PTR _j$[ebp], cl
$LN4@NoRepeat:
  0003e	0f b6 55 fe	 movzx	 edx, BYTE PTR _j$[ebp]
  00042	3b 55 0c	 cmp	 edx, DWORD PTR _length$[ebp]
  00045	73 76		 jae	 SHORT $LN2@NoRepeat

; 159  : 		{
; 160  : 			if (tkIndivs[j].fitness > tkIndivs[i].fitness)

  00047	0f b6 45 fe	 movzx	 eax, BYTE PTR _j$[ebp]
  0004b	6b c8 28	 imul	 ecx, eax, 40
  0004e	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  00052	6b c2 28	 imul	 eax, edx, 40
  00055	8b 55 08	 mov	 edx, DWORD PTR _tkIndivs$[ebp]
  00058	8b 75 08	 mov	 esi, DWORD PTR _tkIndivs$[ebp]
  0005b	f2 0f 10 44 0a
	08		 movsd	 xmm0, QWORD PTR [edx+ecx+8]
  00061	66 0f 2f 44 06
	08		 comisd	 xmm0, QWORD PTR [esi+eax+8]
  00067	76 4f		 jbe	 SHORT $LN1@NoRepeat

; 161  : 			{
; 162  : 				auxTkIndiv = tkIndivs[i+1];

  00069	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  0006d	83 c0 01	 add	 eax, 1
  00070	6b f0 28	 imul	 esi, eax, 40
  00073	03 75 08	 add	 esi, DWORD PTR _tkIndivs$[ebp]
  00076	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0007b	bf 00 00 00 00	 mov	 edi, OFFSET ?auxTkIndiv@?1??NoRepeat@@9@9
  00080	f3 a5		 rep movsd

; 163  : 				tkIndivs[i+1] = tkIndivs[j];

  00082	0f b6 4d fe	 movzx	 ecx, BYTE PTR _j$[ebp]
  00086	6b f1 28	 imul	 esi, ecx, 40
  00089	03 75 08	 add	 esi, DWORD PTR _tkIndivs$[ebp]
  0008c	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  00090	83 c2 01	 add	 edx, 1
  00093	6b fa 28	 imul	 edi, edx, 40
  00096	03 7d 08	 add	 edi, DWORD PTR _tkIndivs$[ebp]
  00099	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0009e	f3 a5		 rep movsd

; 164  : 				tkIndivs[j] = auxTkIndiv;

  000a0	0f b6 45 fe	 movzx	 eax, BYTE PTR _j$[ebp]
  000a4	6b f8 28	 imul	 edi, eax, 40
  000a7	03 7d 08	 add	 edi, DWORD PTR _tkIndivs$[ebp]
  000aa	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000af	be 00 00 00 00	 mov	 esi, OFFSET ?auxTkIndiv@?1??NoRepeat@@9@9
  000b4	f3 a5		 rep movsd

; 165  : 				break;

  000b6	eb 05		 jmp	 SHORT $LN2@NoRepeat
$LN1@NoRepeat:

; 166  : 			}
; 167  : 		}

  000b8	e9 78 ff ff ff	 jmp	 $LN3@NoRepeat
$LN2@NoRepeat:

; 168  : 	}

  000bd	e9 4a ff ff ff	 jmp	 $LN6@NoRepeat
$LN5@NoRepeat:

; 169  : }

  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
_NoRepeat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\jocho\sanpa\seminario de tesis\qilgp\qilgp\utils.c
_TEXT	SEGMENT
_refTkIndiv$ = 8					; size = 4
_compTkIndiv$ = 12					; size = 4
_IsTkIndivBetter PROC

; 54   : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	static byte r = 0;
; 56   : 	if (refTkIndiv->fitness > compTkIndiv->fitness)

  00003	8b 45 08	 mov	 eax, DWORD PTR _refTkIndiv$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _compTkIndiv$[ebp]
  00009	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  0000e	66 0f 2f 41 08	 comisd	 xmm0, QWORD PTR [ecx+8]
  00013	76 06		 jbe	 SHORT $LN3@IsTkIndivB

; 57   : 	{
; 58   : 		return 1; 

  00015	b0 01		 mov	 al, 1
  00017	eb 3c		 jmp	 SHORT $LN4@IsTkIndivB
  00019	eb 38		 jmp	 SHORT $LN1@IsTkIndivB
$LN3@IsTkIndivB:

; 59   : 	}
; 60   : 	else if (refTkIndiv->fitness == compTkIndiv->fitness)

  0001b	8b 55 08	 mov	 edx, DWORD PTR _refTkIndiv$[ebp]
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _compTkIndiv$[ebp]
  00021	f2 0f 10 42 08	 movsd	 xmm0, QWORD PTR [edx+8]
  00026	66 0f 2e 40 08	 ucomisd xmm0, QWORD PTR [eax+8]
  0002b	9f		 lahf
  0002c	f6 c4 44	 test	 ah, 68			; 00000044H
  0002f	7a 22		 jp	 SHORT $LN1@IsTkIndivB

; 61   : 	{
; 62   :         /*if (refTkIndiv->length > compTkIndiv->length)
; 63   :         {
; 64   : 		    return 1;
; 65   :         }
; 66   :         else
; 67   :         {*/
; 68   : 		  r = ((byte)(genrand_int32()) % 2);

  00031	e8 00 00 00 00	 call	 _genrand_int32
  00036	0f b6 c8	 movzx	 ecx, al
  00039	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  0003f	79 05		 jns	 SHORT $LN6@IsTkIndivB
  00041	49		 dec	 ecx
  00042	83 c9 fe	 or	 ecx, -2			; fffffffeH
  00045	41		 inc	 ecx
$LN6@IsTkIndivB:
  00046	88 0d 00 00 00
	00		 mov	 BYTE PTR ?r@?1??IsTkIndivBetter@@9@9, cl

; 69   : 	      return r;

  0004c	a0 00 00 00 00	 mov	 al, BYTE PTR ?r@?1??IsTkIndivBetter@@9@9
  00051	eb 02		 jmp	 SHORT $LN4@IsTkIndivB
$LN1@IsTkIndivB:

; 70   : 			//return 0;
; 71   :         //}
; 72   : 	}
; 73   : 
; 74   : 	return 0;

  00053	32 c0		 xor	 al, al
$LN4@IsTkIndivB:

; 75   : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_IsTkIndivBetter ENDP
_TEXT	ENDS
END
